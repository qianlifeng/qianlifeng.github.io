<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Scott Qian</title><link>https://blog.qlf.io/post/</link><description>Recent content in Posts on Scott Qian</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 17 Nov 2015 16:55:17 +0000</lastBuildDate><atom:link href="https://blog.qlf.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>使用log4jdbc-log4j2记录完整的SQL执行语句</title><link>https://blog.qlf.io/post/log4jdbc-log4j2/</link><pubDate>Tue, 17 Nov 2015 16:55:17 +0000</pubDate><guid>https://blog.qlf.io/post/log4jdbc-log4j2/</guid><description>平常在使用 Hibernate 的 show_sql 开关的时候，打印出来的 sql 不是真实的 sql，参数都是?。在调试性能的时候比较蛋疼。利用log4jdbc-log4f2可以达到打印完整 SQL 的要求，甚至他还可以打印出执行的结果集
注意，我这边使用的 logback(slf4j)作为日志记录组件，如果你不是使用的 logback，那么如下方法可能对你不适用，请查看官网文档
加入如下 Maven 包：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.bgee.log4jdbc-log4j2&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;log4jdbc-log4j2-jdbc4&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.16&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${slf4j.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${logback.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;log4j-over-slf4j&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${slf4j.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jcl-over-slf4j&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${slf4j.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jul-to-slf4j&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${slf4j.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 更改数据库连接，由原来的
jdbc:mysql://localhost:1527 改为
jdbc:log4jdbc:mysql://localhost:1527 更改 JDBC Driver，由原来的 com.mysql.jdbc.Driver 改为
net.sf.log4jdbc.sql.jdbcapi.DriverSpy 添加 log4jdbc.log4j2.properties 配置文件 log4jdbc.spylogdelegator.name=net.sf.log4jdbc.log.slf4j.Slf4jSpyLogDelegator 最后在 logback.</description></item><item><title>SSH打洞大法</title><link>https://blog.qlf.io/post/ssh-tunnel/</link><pubDate>Mon, 28 Sep 2015 11:35:17 +0000</pubDate><guid>https://blog.qlf.io/post/ssh-tunnel/</guid><description>SSH 在手，天下我有
暴露内网端口给外网 使用场景 开发联调。别人只能访问到你的外网地址，但是你想在本地机器监测并调试 内网内容资源展示 基本流程就是别人访问外网，然后外网转发到内网，实际的内容是在内网。因为外网不能主动访问到内网，所以下面这条命令一定要从内网运行。
#暴露内网的3306给remotehost的9123，这样别人访问外网的9123实际就是访问的内网的3306 ssh -R 9123:127.0.0.1:3306 username@remotehost 流量转发 使用场景 本地不能直接连接处于内网的 mysql，可以通过 ssh forward 上去 这条命令会转发本地3308的流程到mysqlhost的3306端口 ssh -L 3308:mysqlhost:3306 user@sshhost 还是比较好区分这两种命令的。R 代表 remote，L 代表 local，如果是-R 表示 remote -&amp;gt; local，-L 标志 local-&amp;gt;remote</description></item><item><title>Akka in action</title><link>https://blog.qlf.io/post/akka-in-action/</link><pubDate>Tue, 08 Sep 2015 16:35:17 +0000</pubDate><guid>https://blog.qlf.io/post/akka-in-action/</guid><description>AKKA 起步 本文使用 Maven 作为依赖管理工具。新建一个最基本的 Maven console 项目，并在 pom.xml 中加入如下依赖：
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.typesafe.akka&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;akka-actor_2.10&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.3.12&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 新建一个UserActor。Actor 是一个封装了状态和行为的 Java 对象，Actor 之间通过交换消息来进行通信。
import akka.actor.UntypedActor; import akka.event.Logging; import akka.event.LoggingAdapter; public class UserActor extends UntypedActor { LoggingAdapter log = Logging.getLogger(getContext().system(), this); public void onReceive(Object message) throws Exception { log.info(&amp;#34;Received String message: {}&amp;#34;, message); getSender().tell(&amp;#34;got it&amp;#34;, getSelf()); } } 在Main方法中新建ActorSystem，并向UserActor发送消息
import akka.actor.ActorRef; import akka.actor.ActorSystem; import akka.actor.Props; public class App { public static void main(String[] args) { final ActorSystem system = ActorSystem.</description></item><item><title>禁用Intellij的注解自动折行</title><link>https://blog.qlf.io/post/disable-method-annotation-on-intellij/</link><pubDate>Sat, 15 Aug 2015 18:53:17 +0000</pubDate><guid>https://blog.qlf.io/post/disable-method-annotation-on-intellij/</guid><description>在 Intellij 中，自动格式化代码的时候，方法的注解默认会被格式化到单独的一行中，看着非常不爽，遂改之
原来默认格式化后的结果如下，个人以为非常难看
@RequestMapping(value = &amp;#34;/test&amp;#34;) public @ResponseBody String index() { return &amp;#34;qlf&amp;#34;; } 修改之后的格式化效果：
@RequestMapping(value = &amp;#34;/test&amp;#34;) public @ResponseBody String index() { return &amp;#34;qlf&amp;#34;; } 具体的修改位置：
File -&amp;gt; Settings -&amp;gt; Editor -&amp;gt; Code Style -&amp;gt; Java -&amp;gt; Wrapping and Braces -&amp;gt; Method Annotations 改为 Do not warp 即可。</description></item><item><title>ngrok</title><link>https://blog.qlf.io/post/ngrok/</link><pubDate>Thu, 16 Jul 2015 17:57:17 +0000</pubDate><guid>https://blog.qlf.io/post/ngrok/</guid><description>ngrok 是一款内网穿透神器，可以直接将内网的端口暴露到外网，实在是居家必备神器。
下载并安装 Go cd ~/download wget https://storage.googleapis.com/golang/go1.4.2.linux-amd64.tar.gz tar -xvf go1.4.2.linux-amd64.tar.gz cp -R go /usr/local cp /usr/local/go/bin/* /usr/bin 下载 ngrok cd ~/github git clone https://github.com/inconshreveable/ngrok.git cd ngrok 开始编译 ngrok 首先为根域名生成证书 export NGROK_DOMAIN=&amp;#34;yourdomain.com&amp;#34; openssl genrsa -out rootCA.key 2048 openssl req -x509 -new -nodes -key rootCA.key -subj &amp;#34;/CN=$NGROK_DOMAIN&amp;#34; -days 5000 -out rootCA.pem openssl genrsa -out device.key 2048 openssl req -new -key device.key -subj &amp;#34;/CN=$NGROK_DOMAIN&amp;#34; -out device.csr openssl x509 -req -in device.</description></item><item><title>Spring AOP小试</title><link>https://blog.qlf.io/post/spring-aop/</link><pubDate>Tue, 14 Jul 2015 20:47:17 +0000</pubDate><guid>https://blog.qlf.io/post/spring-aop/</guid><description>第一次使用 Spring 的 AOP 拦截，感觉还是很强大的嘛^Q^
直接来一个最简单的例子，实现一个方法同步的切面。要求是所有注解了@Synchronized的方法都必须同步执行（加锁）。 效果如下：
@Synchronized public void imporOrder(){ //todo: logic } 如何实现呢？ 首先声明注解：
import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** * 顺序执行方法，防止高并发下的执行顺序问题 */ @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Synchronized { } 接着声明切面
import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Component @Aspect @Order(1) public class SynchronizedAspect { public final static Object locker = new Object(); @Around(&amp;#34;@annotation(cn.fcgyl.oms.aspect.Synchronized)()&amp;#34;) public Object doSynchronize(ProceedingJoinPoint pjp) throws Throwable { synchronized (locker) { Object retVal = pjp.</description></item><item><title>Nodejs与Java的性能比较</title><link>https://blog.qlf.io/post/performance_between_nodejs_and_java/</link><pubDate>Wed, 03 Jun 2015 15:41:17 +0000</pubDate><guid>https://blog.qlf.io/post/performance_between_nodejs_and_java/</guid><description>最近遇到一个项目需要提供这样一种 RESTful 的查询接口：
接口比较独立，内部没有复杂的业务逻辑，基本就是查询数据库 接口查询量会非常大，所以希望能有很好的吞吐量 因为接口比较独立，没有业务逻辑负担。所以我们可以选择的方向就比较多，其中两个方向是 Nodejs 和 Java。Java 是目前项目的主要开发语言，考虑 Nodejs 是看中了他的非阻塞的异步 IO。 而本篇文章的目的就是模拟这两种语言在我们真实使用场景下的表现。
吞吐量与 PV 开始之前，我们需要先了解几个名词，这对我们后面分析比较数据会有一定帮助。
吞吐量：每秒钟完成的请求数。 PV：PV 是 page view 的简写。PV 是指页面的访问次数，每打开或刷新一次页面，就算做一个 pv。 他们之间存在如下的简单换算：
每台服务器每秒处理请求的数量=((80% × 总PV量)/(24小时 × 60分 × 60秒 × 40%)) / 服务器数量。 其中关键的参数是 80%、40%。表示一天中有 80%的请求发生在一天的 40%的时间内。24 小时的 40%是 9.6 小时，有 80%的请求发生一天的 9.6 个小时当中。 所以说，如果你的网站每秒能处理 600 个请求，那么你大概能抗住每日 2500W 的 PV 请求。当然这里只是理想情况下的简单换算，真实环境可能会与这个值有出入。
一些规则 在进行比较之前，我们需要先确定一些规则：
双方尽量使用最原生最简单的实现，排除第三方库的性能干扰。 在同一台机器上进行测试（CentOS, 130G 内存，Xeno E5-2640 v3 @ 2.6GHz 32 核） 对同一数据集进行查询 (包含 200W 记录的表) 测试流程为：请求来了之后，程序会从 10 个候选的 ID 中随机抽取一个进行数据库查询，并将查询的结果返回到页面 测试环境都是默认配置 准备数据库 首先，使用如下 python 脚本 fake 出我们的测试数据。我这里生成了一张 200W 行数据的表。后面就针对该表进行查询</description></item><item><title>SpringMVC入门</title><link>https://blog.qlf.io/post/spring-mvc-in-action-1/</link><pubDate>Mon, 01 Jun 2015 16:06:00 +0000</pubDate><guid>https://blog.qlf.io/post/spring-mvc-in-action-1/</guid><description>写一个最小可运行且无 XML 配置（看到大坨大坨的 XML 配置就烦）的 Spring MVC 程序。
建立项目 首先，你需要下载 Maven。关于 Maven 的使用，请参考我写的这篇入门文章。按照 Maven 的约定，我们建立如下目录结构：
--src --main |--java | |--com | |--scottqian | |--controllers /*控制器目录*/ | | --HomeController.java | |--Application.java /*程序入口*/ |--resources |--templates /*模板目录*/ |--home.html --pom.xml 其中，HomeController.java内容如下
package com.scottqian.controllers; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; @Controller public class HomeController { @RequestMapping(&amp;#34;/&amp;#34;) public String Home(@RequestParam(value=&amp;#34;name&amp;#34;, required=false, defaultValue=&amp;#34;World&amp;#34;) String name, Model model) { model.addAttribute(&amp;#34;name&amp;#34;, name); return &amp;#34;home&amp;#34;; } } 本身结构就比较清晰了，对 MVC 有点了解的从字面上看都应该知道它的意思了（先抛开@Controller 这种注解不谈）。唯一可能疑惑的地方是Home方法的返回值，这里返回的是一个字符串。这个字符串代表了视图的名字，在 SpringMVC 2.</description></item><item><title>使用Maven构建项目</title><link>https://blog.qlf.io/post/maven-start/</link><pubDate>Thu, 28 May 2015 15:43:00 +0000</pubDate><guid>https://blog.qlf.io/post/maven-start/</guid><description>自动化构建，从 Maven 开始~
先看官方定义，Maven 被定义为一套可用于管理项目的构建，报告和文档的工具。使用自动构建工具有利于项目的 部署，测试等，让开发人员从繁琐的编译发布中解脱出来。
Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information. 建立项目 本着约定甚于配置的原则，Maven 有一套默认的约定项目结构。作为例子，这里创建如下目录结构：
--src --main --java --hello 在 hello 目录下面，建立两个文件。分别为 HelloWorld.java 和 Greeter.java
package hello; public class HelloWorld { public static void main(String[] args) { Greeter greeter = new Greeter(); System.</description></item><item><title>SSL协议运行机制</title><link>https://blog.qlf.io/post/ssl/</link><pubDate>Tue, 05 May 2015 14:47:17 +0000</pubDate><guid>https://blog.qlf.io/post/ssl/</guid><description>最近两天在研究关于安全方面的东西，必不可少的需要了解一下 Https/SSL 的通信原理，在这里将了解的结果做个总结。
首先，SSL 的通信过程大体可以分为两个阶段：密钥交换（也有的称之为握手）和正式传输。
密钥交换/握手阶段 首先客户端像服务器发送加密连接请求
服务端接收到请求之后，给客户端发送包含 Public Key 的证书
这里之所以不直接发送 Public Key，而是将公钥放在证书中发送给客户端，是因为这样可以防止 Public Key 被篡改。只要证书是可信的，那么 Public Key 就是可信的。另外这个证书通常又叫做 X.509 证书，这个证书由 CA(Certificate Authority)颁发。
客户端校验证书的合法性。然后客户端生成一个对称加密密钥。并用服务端发送过来的 Public Key 进行加密，最后将加密过后的密钥发送给服务器端 为什么要多生成一个密钥进行加密传输，而不是直接使用 Public key 进行加密？
非对称加密，比较安全，但是加解密大量数据的时候性能不行。而对称加密性能好，但是双方密钥都一样，安全性不好。所以 SSL 采用的方法是仅使用非对称加密来加密对称加密的密钥，然后再用这个加密过的密钥加密传输数据。
如何进行证书合法性校验？
客户端，一般是浏览器，会查找计算机上面的可信证书链，确保发过来的证书是受信任的证书。
服务端用 Private Key 解密发送过来的密钥 这样双方就在一种可信任的环境下获得了加解密数据的密钥，以后所有的通信数据都通过这个密钥来进行加解密。
传输阶段 经过上面的握手阶段，双方都获得了加密密钥后，直接使用 HTTP 层的协议传输加密过后的数据即可。</description></item><item><title>Netgear4300折腾记</title><link>https://blog.qlf.io/post/netgear4300+pi/</link><pubDate>Sun, 26 Apr 2015 17:08:17 +0000</pubDate><guid>https://blog.qlf.io/post/netgear4300+pi/</guid><description>在同事的推荐下，入了 WNDR4300 路由器。天猫 335 买的，好像比某东做活动的时候还贵不少。anyway，等不到那个时候啦。配合上次买的树莓派，可以开始折腾啦。
首先，把目标定下来，我理想中的样子应该是：
能够远程下载。不管是在外面还是在家里，直接在 web 上操作一下即可 小型 NAS。可以多个设备访问移动硬盘中的资源，包括在线播放远程下载的电影等 外部直接能 SSH 到我的树莓派上，例如ssh pi.xxxx.com 路由器应该直接翻墙，这样家里所有的设备都可以透明访问被墙网站 路由器刷 OpenWRT 首先，咱们要把路由器刷成openwrt系统，这样才能让一切 成为可能。去 openwrt 官方网站下载针对 4300 的 rom：openwrt-ar71xx-nand-wndr4300-ubi-factory.img 。
刷机方法：
有线连上路由器的一个 LAN 口，并把电脑 IP 设置为 192.168.1.2，掩码设成 255.255.255.0
在 Windows 控制面板 -&amp;gt; 程序 -&amp;gt; 打开或关闭 Windows 功能 里面勾选 TFTP 客户端
关闭路由器。用小针按住路由器后面的 reset，然后打开路由器电源。刚开始会是电源灯在黄色闪烁 ，然后变成绿色闪烁。此时可以松开 reset
打开命令行，输入如下命令，如果出现传输成功的字样，说明刷机开始
tftp -i 192.168.1.1 put openwrt-ar71xx-nand-wndr4300-ubi-factory.img 待确认路由器重启成功后(比如可以登录http://192.168.1.1)，直接关闭路由器电源等待 5 分钟然后再打开电源，否则可能出现 5G WiFi 不可用的问题</description></item><item><title>树莓派2</title><link>https://blog.qlf.io/post/raspberrypi2/</link><pubDate>Fri, 13 Mar 2015 19:30:42 +0000</pubDate><guid>https://blog.qlf.io/post/raspberrypi2/</guid><description>买的树莓派 2 终于到啦，这里介绍一下基本的上手准备工作。
无图无真相，上图 无线网络配置 拿到手第一件事情就是把无线网给配置起来，这样以后就不用网线了。首先通过有线 SSH 上去，然后运行命令：
lsusb 看看你的无线模块是不是已经被系统识别。如果出现最后一行信息，则说明已成功识别
Bus 001 Device 002: ID 0424:9514 Standard Microsystems Corp. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. Bus 001 Device 004: ID 0bda:8176 Realtek Semiconductor Corp. RTL8188CUS 802.11n WLAN Adapter 然后编辑如下文件
sudo vi /etc/network/interfaces 在这个文件里可以配置网络相关的配置。我这里是使用的静态 IP，这样方便以后 SSH 上去
auto lo iface lo inet loopback iface eth0 inet dhcp auto wlan0 allow-hotplug wlan0 iface wlan0 inet static wpa-ssid &amp;quot;网络名（大小写敏感）&amp;quot; wpa-psk &amp;quot;密码&amp;quot; address 192.</description></item><item><title>Windows上的实用工具推荐</title><link>https://blog.qlf.io/post/software-recommandation/</link><pubDate>Tue, 10 Feb 2015 21:15:17 +0000</pubDate><guid>https://blog.qlf.io/post/software-recommandation/</guid><description>Windows 首先当然是我写的 Launcher Wox啦，开源免费 最近刚刚发现的一个好用的截图工具 ShareX，开源免费 Linux Tmux 用来代替 screen 的强大 shell 工具。两大特点：支持分屏&amp;amp;意外退出 shell 后仍然保存会话</description></item><item><title>拒绝恶意扫描登陆</title><link>https://blog.qlf.io/post/refuse-malicious-scanning/</link><pubDate>Sun, 02 Nov 2014 21:53:17 +0000</pubDate><guid>https://blog.qlf.io/post/refuse-malicious-scanning/</guid><description>如今的互联网世界中，没有机器孤岛。你的机器总于其他人的机器有着千丝万缕的联系。于是，攻击就来了。
这不，最近自己的 VPS 被各种不明的 IP 扫端口，尝试登陆 SSH 等各种恶意行为光顾着。不知道的同学可以查看一下/var/log/auth.log看看里面有多少次失败的尝试登陆，估计吓你一跳。那如何预防呢？
最简单粗暴的方法就是更改默认的 SSH 端口了。方法如下：
更改/var/etc/sshd_config文件，将里面的 22 端口改为其他的端口号，例如：7216 重启 SSH 服务。service ssh restart 还有一个更加&amp;quot;智能&amp;quot;的方法就是使用fail2ban，这个工具会自动分析系统日志中那些恶意的扫描登陆，然后将他们 ban 掉。我也装了一个，不过具体效果还没有验证。有兴趣的同学可以试着安装一个。</description></item><item><title>快速启动器Wox</title><link>https://blog.qlf.io/post/wox/</link><pubDate>Wed, 29 Oct 2014 18:53:17 +0000</pubDate><guid>https://blog.qlf.io/post/wox/</guid><description>其实在正式写 Wox 之前，我就一直想写一款快速启动工具。因为自己本身快捷键用的很多，特别是用了 Vim 之后。自带的Win + R感觉不能搜索程序，比较鸡肋。这中间也使用过Launchy，但是总感觉好久不维护的样子，后面慢慢也放弃掉了。大概 2011 年的时候也用 C 语言做过一些这方面的尝试，fstart 和 smartrun。但是不知道是程序功底不够呢，还是 C++实在太烂，最后也丢弃掉了。然后大概是 2013 年的 11 月份知道了 Mac 有个Alfred，惊为神器，网上也是好评如潮。可惜 windows 下面没有这玩意儿:(
于是，自然而然的就萌生了一些 Windows 下面的类似 Alfred 的软件，连名字一开始都是取得 WinAlfred。开始写的时候在 V2ex 上发了帖子，得到了一些人的肯定，后来也渐渐有一些人参与到这个项目当中来。中间被 Alfred 发来的邮件警告说不能用包含 Alfred 的名字，因为那是他们的商标。最终，在 v2ex 上让大家起了个名字，就是现在的 Wox 啦。
介绍 Wox 是一款启动器。用于快速搜索本机安装的各种程序，文件。也可以通过插件快速搜索网络内容，比如今天天气如何，某某电影的评分是多少等等。
Wox 是开源的，开源地址：http://www.github.com/qianlifeng/wox，欢迎 Pull Request 或者任何的 Issue。
系统插件 Wox 的插件体系分为两个方面，系统插件和第三方插件。系统插件一般不需要关键字触发（Web Search 插件除外），而第三方插件都需要一个关键字触发。例如，我想使用有道翻译的插件，那么则需要使用yd + 空格 + 翻译内容进行触发。这个触发关键字可以配置，另外在后续的文章中我会介绍如何通过快捷键来简化这个过程。
程序插件(Programs)
把这个系统插件放到第一个介绍，足可见他的重要性。Wox 最核心也是最基本的一个功能就是快速启动程序。
Wox 程序插件集成了拼音检索的功能。用户可以直接用拼音或拼音首字母搜索程序，这对国人来说是一项很便利的优化。而且 Wox 搜索列表中的每一项都有自己的权重值。每次选择一项后，该项的权重会增大。这样下次再次搜索此项的时候，该项将会优先显示在列表前面。
Wox 程序搜索列表主要从两个地方获取。
开始菜单中的程序 Wox 会自动收集开始菜单中的程序列表并索引之后供用户进行搜索。</description></item><item><title>安装python三方包到virtualenv</title><link>https://blog.qlf.io/post/install_python_windows_packages_into_virtualenvs/</link><pubDate>Mon, 20 Oct 2014 20:53:17 +0000</pubDate><guid>https://blog.qlf.io/post/install_python_windows_packages_into_virtualenvs/</guid><description>Python 有些依赖包在 windows 需要自己编译安装，配置编译环境这些就已经够烦人的了，最关键的是环境配置对了有时候在编译的过程中还是会出现各种莫名其妙的错误。此时，一个预编译好的安装文件就显得很有必要了。
http://www.lfd.uci.edu/~gohlke/pythonlibs/这个网站里面就包含了很多在 windows 下面安装比较复杂的 python 三方库，包括lxml,jinja2,psycopg等等。如果你不用 virtualenv，那么默认下载下来直接安装就行了。
如果你需要将下载的可执行文件包安装到已经存在的 virtualenv 中，那么可以使用如下命令进行安装。
virtualenv\script\easy_install.exe &amp;lt;your executable file path&amp;gt;</description></item><item><title>使用Supervisor管理程序</title><link>https://blog.qlf.io/post/start-django-with-supervisor/</link><pubDate>Fri, 25 Jul 2014 18:27:17 +0000</pubDate><guid>https://blog.qlf.io/post/start-django-with-supervisor/</guid><description>人生苦短，我用 Supervisor
首先通过如下命令安装 supervisor
sudo apt-get install supervisor 安装完成之后，默认的配置文件应该在/etc/supervisor/conf.d/下面，此后你如果想创建一个新的使用 supervisor 运行的程序，则在此文件夹里面添加配置文件。
这里提供一个参考例子：
[program:name] command = uwsgi --ini your_uwsgi_path autorestart = true stopsignal = QUIT stdout_logfile = log_path redirect_stderr = true 创建完之后使用如下命令启动程序即可
supervisorctl start name Supervisor 还提供了 web 界面管理进程。
可以在/etc/supervisor/config.conf里面进行配置：
[inet_http_server] port = 127.0.0.1:8011 username = scott password = yourpassword</description></item><item><title>使用OpenCV进行简单验证码识别</title><link>https://blog.qlf.io/post/captcha-recognition-using-opencv/</link><pubDate>Sun, 29 Jun 2014 18:55:17 +0000</pubDate><guid>https://blog.qlf.io/post/captcha-recognition-using-opencv/</guid><description>最近对计算机视觉产生了点兴趣，具体来说应该是简单的图形识别方向。本文介绍了如何使用 OpenCV 进行简单的验证码识别。
从头开始学习计算机视觉需要很强的数学功底，从图像预处理到图像匹配都需要用到数学知识，这对于我们这种初学者来说绝对是道很大很大很大很大&amp;hellip;..很大的门槛（原谅我对数学敬畏!_!）。不过，不要灰心，我们还有神器OpenCV。OpenCV 是一套开源的计算机视觉库，他封装了许多计算机视觉处理中常用的方法。在我们这边文章中，我们主要用到了他的阈值处理，轮廓查找，KNN 分类器等等。
先看成品： http://nbviewer.ipython.org/gist/qianlifeng/95023d6c8ce8b28518b8
我摘一些主要的代码片段介绍一下：
原始图像：
所有的验证码处理一般都会先对图像进行一些预处理，包括去除噪点，灰度化，二值化，去除干扰线等等。二值化是为了降低图片的维度，从原来的 RGBA 变为只有 0 和 1 的一维数组。我们使用 cvtColor 进行灰度化处理。
gray = cv2.cvtColor(im,cv2.COLOR_BGR2GRAY) 接着去噪，简单的去噪原理如下。我们会设置一个阈值，高于这个阈值的点变为黑色，低于的变成白色。（这里使用的是名为自适应阈值的去噪方法，效果好一点）
threshold = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY, 11, 40) 到这边图像预处理基本已经差不多了，剩下来就是寻找里面的图像轮廓，进行切图。
(cnts, _) = cv2.findContours(ts.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) 这句话会找出图片给里面所有的轮廓信息，当然里面有很多无用的轮廓，比如 0 这个数字，他会找出两个轮廓出来。一个是 0 的外圈，一个是 0 的内圈。我们还需要一些简单的代码去除这些多余的轮廓。
cmax = 100 cmin = 20 cts = [] for item in cnts: if cmin &amp;lt; len(item) &amp;lt; cmax: (x,y,w,h) = cv2.boundingRect(item) cts.append((x,y,w,h)) 未完待续!</description></item><item><title>Github+Hexo+Travis打造史上最懒博客</title><link>https://blog.qlf.io/post/my_new_choise_for_blogging/</link><pubDate>Fri, 20 Jun 2014 19:33:00 +0000</pubDate><guid>https://blog.qlf.io/post/my_new_choise_for_blogging/</guid><description>我前面写过使用Hexo 发布静态博客的文章。静态博客抛弃了原本笨重的写作方式，NO 数据库，NO Web 程序，而且生成后的 html 随便放到哪个 Server 都能显示。如果使用了数据库还必须安装 Mysql 等等之类的数据库服务，以后还得数据库备份啊，还原啊什么的，想想就头疼。所以，使用静态博客对我而言看来是个不错的选择。我今天要介绍的则是将这一方式做的更加彻底一点，摆脱手动编译的麻烦，利用Github + Travis 自动编译发布文章（程序员果然就是懒~_~）。
我以前使用 Hexo 的时候，都是手动执行hexo generate后，再利用Bit Torrent Sync 将 public 文件夹同步到我买的DigitalOcean(小尾巴走起~~)主机上。虽说一直也没出过什么问题，不过总感觉这样还是不够轻量级，因为你需要在服务端和本地安装Bit Torrent。而我希望的是最好能简化到直接打开某个网页，新建一个 xxxx.md，编辑然后保存。此时我的博客就应该跟着更新了。经过一番探索，果然通过 Github+Travis 还是可以实现的。
创建 Gihutb 仓库 首先，你需要在 Github 上面创建一个新的 Repository 用来存放你的博客，名字有一定的要求，比如你的 Github 用户名是qianlifeng，那这个新建的 Repsoitory 必须叫qianlifeng.github.io。此时，你在新建的仓库里面放入一个 index.html 文件，然后访问http://qianlifeng.github.io就可以看到这个 index.html 的网页了。
除了默认的master分支，我们需要建立一个source分支专门用来存 hexo 放源文件。master分支则存放 hexo 生成之后的 html 文件。
启用 Travis 自动集成 Travis 是一个持续集成（Continue Integrate）的服务，对于开源的 Github 项目它是免费的。你需要到他的网站使用 Github 账户登录，然后设置页面打开我们刚才新建的那个仓库的持续集成的开关即可。
在source分支中新建.travis.yml文件用于 Travis 的一些配置。参加如下：
branches: only: - source language: node_js node_js: - &amp;#34;0.</description></item><item><title>Nodejs写一个简单爬虫</title><link>https://blog.qlf.io/post/nodejs-crawler-start/</link><pubDate>Mon, 03 Mar 2014 21:04:17 +0000</pubDate><guid>https://blog.qlf.io/post/nodejs-crawler-start/</guid><description>Nodejs最近两年火的不行啊，作为半个前端（好吧，最近写公司项目写的快变成半个前端了，再下去是不是要全端了）我也来试着用 nodejs 写个最简单的爬虫，体验一把 nodejs。
首先下载 Nodejs 什么的就不说了，直接下一步。Nodejs 的包管理工具 NPM 也会同时被安装。这点做得比 python 好，装个 pip 还要自己动手。话说 c#也有个 nuget，好像包管理必不可少啊现在。安装好之后，使用 npm 安装如下两个依赖库：
npm install request npm install cheerio 注意，安装的时候一定要先将命令行跳到你项目文件所在的目录，然后进行安装。否则安装之后会出现 request 找不到的错误。其中 request 是用来请求数据的，cherrio 是用 jquery 的语法来解析 html 的，对于熟悉 jquery 的童鞋来说十分方便。 上代码:
var request = require(&amp;#34;request&amp;#34;); var cheerio = require(&amp;#34;cheerio&amp;#34;); request(&amp;#34;http://news.dbanotes.net/&amp;#34;, function(error, response, body) { if (!error &amp;amp;&amp;amp; response.statusCode == 200) { var $ = cheerio.load(body); $(&amp;#34;tr td.title a&amp;#34;).each(function() { console.log(&amp;#34;%s (%s)&amp;#34;, $(this).text(), $(this).attr(&amp;#34;href&amp;#34;)); }); } }); 从这个小例子来看还是蛮简单的噢，执行结果如下：</description></item><item><title>Vim插件推荐</title><link>https://blog.qlf.io/post/vim-plugin-introduction/</link><pubDate>Sat, 18 Jan 2014 16:22:17 +0000</pubDate><guid>https://blog.qlf.io/post/vim-plugin-introduction/</guid><description>陆陆续续使用 Vim 也差不多快一年多了，从一开始的几次放弃到现在越用越习惯。在这当中也折腾了许久，最主要的就是 Vim 中各种各样的插件。
对于软件，我在这里看到一种观点比较有趣。作者把好的软件大致分为两类：瑞士军刀和工具链。所谓瑞士军刀指的是那些在某些特定领域做的很强大的软件。这类软件不需要折腾又需要折腾。所谓不需要折腾是因为一般这类软件在此领域中都很强悍，你折腾来折腾去最终一定会折腾到这个软件上面，一旦熟练使用了此软件那么其他的类似软件已经完全不需要折腾了。而所谓需要折腾是指通常这类软件都有一个比较陡峭的学习曲线，从不会不习惯到熟练使用的过程就是一个折腾与磨合的过程。
大概 Vim 就是这样的一个软件，而我磨合的结果就是下面列出的插件。
vundle 推荐星级：★★★★★
Vim 插件管理工具。使用此工具后安装 Vim 插件会变成一件很简单的事。只需要在 vimrc 中声明一行类似于这样的代码：
Bundle 'kien/ctrlp.vim' 然后使用命令：BundleInstall。此时 vundle 会自动安装声明的插件，简单方便。我下面介绍的插件都是使用这种方式安装的。
ctrlp.vim 推荐星级：★★★★★
这是一款用于模糊查找文件的插件。它可以搜索文件，buffer列表等。我最喜欢的功能是打开MRU列表，即我最近经常使用的文件列表。下面是我对于它的一些配置文件，主要是把快捷键换成F2了。
Bundle 'kien/ctrlp.vim' &amp;quot;MRU default let g:ctrlp_map = '&amp;lt;F2&amp;gt;' let g:ctrlp_regexp = 1 let g:ctrlp_cmd = 'CtrlPMRU' let g:ctrlp_custom_ignore = '\.git$\|\.hg$\|\.svn$\|.rvm$' &amp;quot;let g:ctrlp_working_path_mode=0 let g:ctrlp_match_window_bottom=1 let g:ctrlp_max_height=15 let g:ctrlp_match_window_reversed=0 let g:ctrlp_mruf_max=500 let g:ctrlp_follow_symlinks=1 The-NERD-Commenter 推荐星级：★★★★★
代码注释插件。这款插件很强大，基本不用考虑你目前编辑的代码语言，它会自动找到符合该语言的注释方式。我目前使用的 c#,python,css,html,js 等无一例外。 配置文件：
&amp;quot; 这里使用的绑定快捷键同VS Bundle 'The-NERD-Commenter' :nmap &amp;lt;C-K&amp;gt;&amp;lt;C-C&amp;gt; &amp;lt;leader&amp;gt;c&amp;lt;space&amp;gt; :imap &amp;lt;C-K&amp;gt;&amp;lt;C-C&amp;gt; &amp;lt;Esc&amp;gt;&amp;lt;leader&amp;gt;c&amp;lt;space&amp;gt;i :nmap &amp;lt;C-K&amp;gt;&amp;lt;C-U&amp;gt; &amp;lt;leader&amp;gt;c&amp;lt;space&amp;gt; :imap &amp;lt;C-K&amp;gt;&amp;lt;C-U&amp;gt; &amp;lt;Esc&amp;gt;&amp;lt;leader&amp;gt;c&amp;lt;space&amp;gt;i The-NERD-tree 推荐星级：★★★★★</description></item><item><title>在nginx上配置flask网站</title><link>https://blog.qlf.io/post/deploy-falsk-with-nginx/</link><pubDate>Tue, 14 Jan 2014 21:46:17 +0000</pubDate><guid>https://blog.qlf.io/post/deploy-falsk-with-nginx/</guid><description>好记性不如烂笔头，前端时间配置这个玩意儿的时候本以为自己已经记得的了。最近再配置还是忘记的一干二净，所以还是记录一下以备后用。
nginx 配置 可以在/etc/nginx/sites-available/目录下新建一个 config 文件，这样便于不同程序之间的分隔，建立完后使用软连接链接到/etc/nginx/sites-enable/下面。 注意这里使用 ln -s 的时候两个路径必须要使用绝对路径，不要使用相对路径。
server { server_name www.xxx.com; error_log /home/error.log; location / { try_files $uri @web; } location @web { include uwsgi_params; uwsgi_pass 127.0.0.1:8090; uwsgi_param UWSGI_CHDIR /home/pythonProject; uwsgi_param UWSGI_MODULE application; uwsgi_param UWSGI_CALLABLE app; } } 完成之后重启 nginx。
service nginx restart 运行网站的命令是：uwsgi -s :8090 -w application:app。
据网上的资料说还应该配置/etc/uwsgi/apps-available下面的内容，但是好像我没配置也正确运行了。各位看官请自己甄别。</description></item><item><title>打包python使其成为单文件可执行程序</title><link>https://blog.qlf.io/post/package-python-files/</link><pubDate>Wed, 18 Dec 2013 18:15:17 +0000</pubDate><guid>https://blog.qlf.io/post/package-python-files/</guid><description>本文介绍了如何使用 pyinstaller 打包 python 程序，使其成为 window 下的单个可执行 exe 文件。
准备工作 安装PyInstaller pip install PyInstaller，具体打包方法后面会提到。
下载UPX，此程序用来压缩程序，效果蛮大。我试验的结果可以缩小一倍的程序体积。
下载完成解压后，将其加入到环境变量中。这样 PyInstaller 在执行的时候可以自动调用这个程序进行压缩。
下载安装Enigma Virtual Box。正常情况下，使用 PyInstaller 打包的文件会有许多依赖文件， 此程序的作用是将这些依赖和主程序进行合并，最后生成一个 exe 程序。
打包 假设现在要打包 p4p.py 文件。直接在命令行下执行：
PyInstaller p4p.py 相比于以前的 PyInstaller，2.0 以后的版本好用了不少。执行上面的命令之后，应该会出现如图一连串的信息: 注意，如果中间出现
INFO: Executing - upx --lzma -q 类似的信息，那么就说明上面提到的 UPX 压缩程序起作用了。生成以后会在同目录下多一个 dist 的文件夹出来，里面就有我们需要的所有文件了，包括一个 exe 的可执行文件。
但是到了这儿还没完。因为我们的目标是单个执行程序，所以我们祭出前面介绍的Enigma Virtual Box。 简单的实在是没什么可以说的，大家看图吧。 有一点需要注意的是右下角有个文件选项，点开之后可以把压缩文件和退出删除都选上，这样体积又能进一步压缩了。我最后打包的单个文件大概 6M 多一点，说大不大说小不小，反正还可以承受。
2013-12-19 更新 刚刚发现其实 PyInstaller 已经自带了类似于Enigma Virtual Box的功能。只需要在执行的时候加一个参数即可：</description></item><item><title>一个Linux命令学习网站</title><link>https://blog.qlf.io/post/useful-linux-commands/</link><pubDate>Tue, 03 Dec 2013 18:15:17 +0000</pubDate><guid>https://blog.qlf.io/post/useful-linux-commands/</guid><description>无意中发现一个学习 linux 命令的网站。http://www.commandlinefu.com/commands/browse/sort-by-votes这上面的命令都是经过投票产生的大家认为最有用的一些命令。进去看看说不定有惊喜哦。
排名第一的命令，围观一下：
sudo !! 作用：以 root 身份重新执行刚刚执行的命令，在某个命令忘记使用 sudo 运行的时候特别有用哟。</description></item><item><title>用screen管理多个SSH远程会话</title><link>https://blog.qlf.io/post/manage-multiple-session-using-screen/</link><pubDate>Sun, 24 Nov 2013 17:15:17 +0000</pubDate><guid>https://blog.qlf.io/post/manage-multiple-session-using-screen/</guid><description>有 VPS 的同学应该会经常使用putty进行 SSH 远程连接吧。新开的每个 SSH 都是一个 session，这么做有一个缺点就是如果当你退出的时候，这个 session 中的任务都会跟着退出。于是 screen 来了。
简单来说，Screen 是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen 中有会话的概念，用户可以在一个 screen 会话中创建多个 screen 窗口，在每一个 screen 窗口中就像操作一个真实的 telnet/SSH 连接窗口那样。
安装 screen sudo apt-get install screen 在 screen 中创建一个新的 session screen -S yourSessionName 这样你就可以新建一个 session，同时 terminal 自动进入到新的 session 环境。在这个环境里面你可以像平常一样操作各种命令，运行长时间运行的脚本等等。
退出 session（非关闭） 可以按 ctrl + A + D。注意是按住 ctrl 然后 A，D 键。此时你又回到了普通的 SSH 环境，而刚才那个 session 仍然运行着。如果想再次进入那个 session，则键入：
screen -r yourSessionName 瞧，你又还原现场了，包括你各种正在运行的脚本。
screen 的其他用法请运行： screen --help</description></item><item><title>开启unbuntu上3306远程连接</title><link>https://blog.qlf.io/post/enable-remote-mysql/</link><pubDate>Fri, 22 Nov 2013 21:15:17 +0000</pubDate><guid>https://blog.qlf.io/post/enable-remote-mysql/</guid><description> 创建一个新的用户，并赋予权限。 mysql&amp;gt; grant all PRIVILEGES on *.* to user@'%' identified by 'pwd'; 把上面的user和pwd换成你自己的用户名和密码。可以通过如下命令查看是否添加成功。 mysql&amp;gt; use information_schema mysql&amp;gt; select * from user_privileges; 查询到有下面的结果：'user'@'%'，说明mysql已经授权远程连接。 在/etc/mysql/my.cnf找到bind-address，将其配置的 127.0.0.1，直接改为你服务器的地址。
如果还不能访问，可以查看 3306 端口是否开启。如果开启了，应该会有结果返回。
netstat -an |grep 3306</description></item><item><title>RESTful api跨域认证</title><link>https://blog.qlf.io/post/restful-api-cross-domain-authentication/</link><pubDate>Wed, 13 Nov 2013 16:24:17 +0000</pubDate><guid>https://blog.qlf.io/post/restful-api-cross-domain-authentication/</guid><description>本文主要介绍了 RESTful api 跨域认证的一些知识。包括了什么是跨域，跨域的危害，如何进行合理的跨域认证等。另文中如有不对的地方，欢迎指正.
前言 在正式介绍 Web Api 跨域认证之前，我想先举一个 web api 跨域认证的例子，就算是需求吧，也有利于后面讲解的时候有例子可说。
假设现在有两台服务器：Server A 和 Server B。 Server A(域名：https://www.serverA.com/api/) 上面运行着一个提供 Web Api 的程序，此程序中的 api 都需要用户登录以后才能操作。Server B(域名：http://www.serverB.com) 也有一个程序，专门用来消费这些 Web PI 。
ServerB 上面有一个登录操作，此操作会去请求 ServerA 上面的某个用户认证 api。要求:
1. 成功请求此api 2. 持久化用户的此次认证，以便用户的后续请求。 什么是跨域 对于上面的要求，如果你直接通过 ajax 请求此认证 api 显然是不行的。为什么？因为这个请求跨域了。那么什么请求才是跨域请求？
所谓跨域请求是指请求一个与当前url协议不同,或者域名不同,或者端口不同的链接资源。 下面这个表格可以帮助理解什么样的请求是跨域请求。
这种不能跨域请求的限制又称为：“Same-Origin Policy”（同源策略）。值得注意的是这种安全限制是 Javascript 保证的，也就是说以后如果出来个新的浏览器端语言不带这种限制，那么你就可以随便请求不同域的资源。还有一个例子可以佐证，你直接使用 wget 命令请求 RESTful api 认证的页面同样会有结果返回。因为此处的请求不是由 javascript 发出，已经没有了同源策略的限制了。
跨域的危害 为什么要采用这种同源策略的限制呢？我们来模拟一下攻击场景。比如说某网站 A 有个 apihttp://localhost:5000/api/getuser，此 API 用来获得当前用户的登陆信息 [ 假设此 API 不需要认证操作 ] 。碰巧的是用户同时在一个新的标签页打开了网站 B。网站 B 下面有这么一段代码：</description></item><item><title>杭州西湖照片2张</title><link>https://blog.qlf.io/post/hangzhou-photo/</link><pubDate>Sun, 10 Nov 2013 22:23:00 +0000</pubDate><guid>https://blog.qlf.io/post/hangzhou-photo/</guid><description>这个周末公司组织去杭州玩了一圈，挑来挑去就两张照片还行。看来拍照水平还是有待加强呀。
这张是偶然拍到的，在浙西大峡谷。 这张用的镜头是同事的 F1.8 的定焦镜头，效果果然不一样，比我的狗头好多了。考虑着是不是也要入一个玩玩呢。</description></item><item><title>nginx二级域名配置小结</title><link>https://blog.qlf.io/post/nginx-subdomain-config/</link><pubDate>Fri, 08 Nov 2013 21:15:17 +0000</pubDate><guid>https://blog.qlf.io/post/nginx-subdomain-config/</guid><description>一直就听说 nginx 很牛逼的样子，这次就在 VPS 上面体验了一把。平常一直混迹于 window 平台下，所以最多也就配配 IIS，而且仅仅限于 UI 这里点点那里点点。使用 nginx 完全是不同的感受，所有配置完全写在配置文件里面，所有东西完全掌控在你手上。极客小伙伴们快来体验一把！
为了以后查阅起来方便，我决定还是从安装开始写，说不定时间一长我连怎么安装配置 nginx 都会记不得了，正好也给新手一个完全指南。注：我使用的 VPS 系统是 Ubuntu
nginx 安装 sudo apt-get install nginx too young too simple 啊。装完了之后，有几个常用的目录我们需要认识一下：
下面这个路径是存放 domain 配置的地方。默认下面应该有个 default 文件。 /etc/nginx/site-available 如果你有不同的域名 a.com,b.com。那么你就可以在这下面建立 a,b 文件分别对这两个域名进行配置，简单的分类作用吧。我们下面要讲到的规则基本上都是在这里面配置的。
这个是 nginx 默认的日志存放路径 /var/log/nginx/ 这里面基本上有两类文件：错误日志error.log,访问日志access.log。后期再配置二级域名的时候，如果配置的不对，过来查看错误日志是很有效的错误定位方法。
配置二级域名 打开上文提到的/etc/nginx/site-available/default文件。键入如下代码（scottqian.com 换成你的域名）：
server { index index.html; server_name ~^(?&amp;lt;subdomain&amp;gt;.+)\.scottqian\.com$; root /home/web/$subdomain/; if ($host != 'www.scottqian.com'){ rewrite ^/(.*)$ http://www.scottqian.com/$1 permanent; } location / { try_files $uri $uri/ =404; } } 注意看server_name那一行。这是一个正则表达式，它匹配所有**.</description></item><item><title>静态博客折腾记</title><link>https://blog.qlf.io/post/static-blog-start/</link><pubDate>Wed, 06 Nov 2013 21:15:17 +0000</pubDate><guid>https://blog.qlf.io/post/static-blog-start/</guid><description>心血来潮突然想搞起静态博客来，为什么呢？
说起博客独立之路也算走的曲折。一开始在博客园写些文章，写着写着就想自己搞一个独立的空间，因为这样定制性高一点，适合自己折腾。后来就买了个虚拟空间，99 块钱 2 年。没错，是 99，不是 999，也不要 199，只要 99。当时穷学生，果断买下。后果你懂的，三天两头的挂机。再后来开始买国外的 VPS，当前用的是 DigitalOcean 的，5$一个月。这个价钱说起来还是可以的，SSD 的配置。买了 VPS，因为自己懒，直接装了个 wordpress。一开始还好，后来经常出现数据库连接不上的问题，另外感觉 wordpress 有的太重量级了，自己插不上手。最后，慢慢就走上静态博客这条路。 静态博客我总结了一下，有以下几点好处：
轻量，如果不管静态生成引擎，那基本上就是和 html 和 js 打交道。没有后台，没有数据库，没有随之带来的各种烦恼。 速度快，因为完全是静态的页面，所以具体无与伦比的速度。 安全，因为都是单纯的静态页面，神马数据库注入啊，跨站攻击啊，都可以洗洗睡了。 部署方便。随便哪种类型的服务端，直接把生成后的页面仍过去就可以工作了。 目前可能够提供生成静态博客的引擎还是有不少的。
Jekyll
Jekyll 因 github 而出名，Github 的 pages 功能便是使用 Jekyll 进行编译。不过是我放弃使用 Jekyll 的原因是其奇怪的模板语法（后来看看其实也还好，不过这东西也讲究缘分的不是^_^）
Pelican
Pelican 是用 python 实现的生成引擎。其最大的缺点是对中文支持不够和编码的问题，经常性的冒出什么不能解码的错误。当然了，这是 python 的通病了。平常自己写写 python 脚本的时候最怕遇到这种编码问题，现在既然存在，当然是远而避之，珍惜生命。
Hexo
Hexo 使用 Node.js 写的，我目前使用的便是这个。最让我惊艳的不是这个引擎有多快，有多简单易用，而是据说这个引擎是台湾的一个大学生写的。知道后立马给跪了，也不知道现在有几个大学生能写出在 github star 能达到上千的作品。当然我目前也不能，虽然我已经不是大学生了，囧!
Hexo Hexo 主打的特点是快，和简单易用。快是因为依托了 Node.js 和强大的多线程处理能力。易用说的是配置简单，开箱即用。 安装 Hexo 只需要简单一句话：</description></item><item><title>动态编译C#代码</title><link>https://blog.qlf.io/post/validate-user-input-by-dynamic-compling-code/</link><pubDate>Tue, 15 May 2012 15:27:00 +0000</pubDate><guid>https://blog.qlf.io/post/validate-user-input-by-dynamic-compling-code/</guid><description>动态编译 C#代码的一次尝试
需求描述 现在一个页面有 4 个输入框，每个输入框都绑定有一个验证规则。要求在用户输入完毕后根据每个输入的规则对用户输入进行验证。而且这些验证规则是用户在后台可以动态更改的。如下图所示： 最初的想法 我们最初的想法使用正则表达式实现。后台数据库中只要存储验证的正则表达式就行了。需要验证的时候，从后台数据库中取得对应的正则表达式即可。 想法很好，就是真正到了实现的时候有点问题。比如上图中的第一个要求如果使用正则表达式来实现就会比较复杂，在网上查了一些资料也没有发现比较通用的能够检测数字范围的正则表达式。最要命的是上面第一个是可以更改的，如果用户突然哪一天更改为：&amp;gt;34.5 &amp;amp;&amp;amp; &amp;lt; 999999.9 那这个正则又该怎么写呢？目前还没有找到一个比较通用的验证数字范围的正则表达式。所以这种不可行。
不过上面有一点肯定的是，将验证规则提取到数据库中达到可配置这个是一定的，只是现在缺少一种行之有效并且简单的表达式。表达式啊表达式&amp;hellip;突然想到 lambda 表达式不也是一种表达式么，如果如果让他来进行类似于范围判断的话也会简单很多。例如，如果要进行上面的范围判断可以写成：o=&amp;gt; o &amp;gt;100 &amp;amp;&amp;amp; o &amp;lt; 499，比正则表达式不知道高到哪里去了。 现在需要考虑的问题就是如何让后台代码从数据库中取出这段 lambda 表达式，并且能够成功执行返回结果。自然而然的想到了动态编译这个词，只要能够动态编译这些代码片段，那么就能执行并返回结果了。
动态编译 c#代码 初步的想法有了，下面就是验证其是否可行了。google 了一番动态编译 c#代码，在博客园园里面搜索到这篇文章http://www.cnblogs.com/jailu/archive/2007/07/22/827058.html。 很详细的教程，在这里谢谢作者。作者给出的代码显然还不能直接用到我们这里。我们需要的接口应该是这样的bool Validate(string lambda, string userInput); 第一个参数是从数据库取出的 lambda 表达式字符串，第二个参数是用户输入的需要进行验证的值。
static bool validateInput(string lambda, string input) { // 1.CSharpCodePrivoder CSharpCodeProvider objCSharpCodePrivoder = new CSharpCodeProvider(new Dictionary&amp;lt;string, string&amp;gt;() { { &amp;quot;CompilerVersion&amp;quot;, &amp;quot;v3.5&amp;quot; } }); // 2.ICodeComplier ICodeCompiler objICodeCompiler = objCSharpCodePrivoder.CreateCompiler(); // 3.CompilerParameters CompilerParameters objCompilerParameters = new CompilerParameters(); objCompilerParameters.</description></item><item><title>python设置windows桌面壁纸</title><link>https://blog.qlf.io/post/change-windows-wallpaper-by-python/</link><pubDate>Thu, 10 May 2012 11:25:00 +0000</pubDate><guid>https://blog.qlf.io/post/change-windows-wallpaper-by-python/</guid><description>每天一个新壁纸，天天好心情。
# -*- coding: UTF-8 -*- from __future__ import unicode_literals import Image import datetime import win32gui,win32con,win32api import re from HttpWrapper import SendRequest StoreFolder = &amp;quot;c:\\dayImage&amp;quot; def setWallpaperFromBMP(imagepath): k = win32api.RegOpenKeyEx(win32con.HKEY_CURRENT_USER,&amp;quot;Control Panel\\Desktop&amp;quot;,0,win32con.KEY_SET_VALUE) win32api.RegSetValueEx(k, &amp;quot;WallpaperStyle&amp;quot;, 0, win32con.REG_SZ, &amp;quot;2&amp;quot;) #2拉伸适应桌面,0桌面居中 win32api.RegSetValueEx(k, &amp;quot;TileWallpaper&amp;quot;, 0, win32con.REG_SZ, &amp;quot;0&amp;quot;) win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER,imagepath, 1+2) def setWallPaper(imagePath): &amp;quot;&amp;quot;&amp;quot; Given a path to an image, convert it to bmp and set it as wallpaper &amp;quot;&amp;quot;&amp;quot; bmpImage = Image.open(imagePath) newPath = StoreFolder + '\\mywallpaper.</description></item><item><title>在chrome中利用“油猴”为每个网页增加“返回顶部”功能</title><link>https://blog.qlf.io/post/back-to-top-chrome-extension/</link><pubDate>Thu, 08 Mar 2012 13:46:00 +0000</pubDate><guid>https://blog.qlf.io/post/back-to-top-chrome-extension/</guid><description>今天在网上看到了“油猴”这么个东西的介绍，感觉蛮有趣，跟大家分享一下。
这个东西本来是火狐的插件，后来一查原来 chrome 从 4.0 以后也支持用户脚本了。所谓的“油猴”实际上是一段以*.user.js 结尾的 js 脚本，通过油猴你可以在每个网页上执行你的这段脚本。 利用这个 js 脚本你可以对网站页面做一些个性化的修改，比如像我们今天提到在每个页面上增加“返回顶部”的功能，其效果就是在每个页面自动添加返回顶部的功能： 创建“油猴”脚本 下面介绍一下如何在 chrome 中编写自己的用户脚本（以增加返回顶部功能为例）
去谷歌扩展中心下载 Tampermonkey ,这个东西可以用来管理各种用户脚本。
安装后进入 Tampermonkey 的设置界面，然后创建一个新的脚本： 在编辑脚本页面输入下面的一段 js 脚本（用于实现“返回顶部”功能）
// ==UserScript== // @name GotoTop // @version 0.1 // @description 给每个网页增加返回顶部按钮 // @match http://* // @match https://* // @copyright scott qian // @require http://ajax.googleapis.com/ajax/libs/jquery/1.6/jquery.min.js // ==/UserScript== ImportCss(); ScriptWithJquery(); BindHotKey(); function ImportCss() { var jqueryScriptBlock = document.createElement('style'); jqueryScriptBlock.type = 'text/css'; jqueryScriptBlock.innerHTML = &amp;quot;#gototop{position:fixed;bottom:20%;right:1px;border:1px solid gray;padding:3px;width:12px;font-size:12px;cursor:pointer;border-radius: 3px;text-shadow: 1px 1px 3px #676767;}&amp;quot;; document.</description></item><item><title>使用python进行新浪微博应用开发</title><link>https://blog.qlf.io/post/create-weibo-app-by-python/</link><pubDate>Sun, 12 Feb 2012 21:43:00 +0000</pubDate><guid>https://blog.qlf.io/post/create-weibo-app-by-python/</guid><description>本文简单的介绍了如何使用新浪微博 API 来做一个简单的微博应用
首先，你需要在新浪开放平台上创建一个应用
在开放平台-我的应用下面创建新的应用。按照提示一步一步创建，傻瓜式的 点击刚才创建的应用进入详细页面，然后查看应用信息-基本信息下面。在程序开发过程中，我们需要 app key 和 app secret 来调用新浪 API 下载对应语言的 sdk。当然这里以 python 为例，下载地址：http://code.google.com/p/sinaweibopy/。下载完成后将里面的 weibo.py 复制到你的应用程序同一目录下，或者复制到 lib/site-package 下。这样你的应用就可以调用 sdk 了。 在你的程序里面做如下测试，如果你幸运的话你应该能得到正确的返回结果了。 from weibo import APIClient APP_KEY = 'xxxx' # app key APP_SECRET = 'xxxx' # app secret CALLBACK_URL = 'xxxxxx'# callback url #利用官方微博SDK client = APIClient(app_key=APP_KEY, app_secret=APP_SECRET, redirect_uri=CALLBACK_URL) #用得到的url到新浪页面访问 url = client.get_authorize_url() webbrowser.open_new(url) #手动输入新浪返回的code code = raw_input() #新浪返回的token，类似abc123xyz456，每天的token不一样 r = client.request_access_token(code) access_token = r.access_token expires_in = r.</description></item><item><title>SQL Server数据的导入导出</title><link>https://blog.qlf.io/post/sqlserver-backup-restore/</link><pubDate>Wed, 08 Feb 2012 10:28:00 +0000</pubDate><guid>https://blog.qlf.io/post/sqlserver-backup-restore/</guid><description>这两天在用新学习的 python 抓新浪微博首页的数据，这些数据都被存在的 sql server 当中。因为白天在公司和晚上在宿舍用的数据库版本不一样，所以如果在宿舍直接附加公司的数据库的话会报错。没办法，只好通过 SQL server 中提供的 BCP 导入导出的办法来同步两个地方的数据。
这里简单记录一下如何使用 BCP 工具进行数据的导入导出。首先 BCP 是 sql server 自带的工具，所以只要你安装了 sql server 后就自带了。在 cmd 中输入 cmd，你会发现他的一些参数说明选项。具体的参数选项大家可以在具体用到的时候再去查看，这里就不一一解释了（实际上我也用的不多 ^_^）
一个最简单的导出示例。如果你有个数据库 A，里面有一个表 B，那么导出 B 数据的命令如下：
BCP A..B out c:\currency1.txt -c -u&amp;quot;sa&amp;quot; -p&amp;quot;123456&amp;quot; 注意 A 和 B 中间有两个..，如果是使用继承验证的话可以去掉-u -p 选项改为-t 就行了。下图是我执行的截图： 此时如果要导入已经导出的数据，执行如下命令：
BCP A..B in c:\currency1.txt -c -U&amp;quot;sa&amp;quot; -P&amp;quot;123456&amp;quot; 可以看到与导出唯一不同的地方就是 out 换成了 in。至此，最简明 sql server 数据导入导出记录完毕！</description></item><item><title>利用python简化sql server数据导入导出</title><link>https://blog.qlf.io/post/simplify-sqlserver-backup-restore/</link><pubDate>Wed, 08 Feb 2012 10:28:00 +0000</pubDate><guid>https://blog.qlf.io/post/simplify-sqlserver-backup-restore/</guid><description>前面我们介绍了如何使用 sqlserver 的 BCP 命令进行数据的导出和导入。使用这个命令一个不足的地方的是不能对整个数据库进行一次性操作。如果表很多的时候就要一个个命令操作，不可谓不麻烦！ 正好最近在学习 python，于是打算用 python 实现了一个简化 bcp 操作的程序。点击程序后就会自动将指定的数据库所有的表的备份数据放到一个特定的目录下。当然，程序也提供对应的自动化导入功能
因为要获得一个数据库中所有的表，所以我使用了 pymssql 来进行数据库操作并进行了简单的封装，形成了 MSSQLHelper 类。具体的 pymssql 的下载和用法大家可以到网上进行搜索。思路很简单：
导入的时候查看是否已经存在特定的导出目录，如果存在则删除该目录下所有的文件 利用 pymssql 读取指定数据库中所有的表名字，对每个表进行 bcp 命令 导入的功能则是省去了删除已存在文件那个操作，其他都差不多。 #!/usr/bin/env python # -*- coding: UTF-8 -*- #------------------------------------------------------------------------------- # Name: 导出数据库数据.py # Purpose: # # Author: SQ1000 # # Created: 08-02-2012 #------------------------------------------------------------------------------- import os import pymssql import sys class MSSQLHelper: &amp;quot;&amp;quot;&amp;quot; 对pymssql的简单封装 pymssql库，该库到这里下载：http://www.lfd.uci.edu/~gohlke/pythonlibs/#pymssql 使用该库时，需要在Sql Server Configuration Manager里面将TCP/IP协议开启 用法： &amp;quot;&amp;quot;&amp;quot; def __init__(self,host,user,pwd,db): self.host = host self.</description></item><item><title>EasyVS - Visual Studio扩展</title><link>https://blog.qlf.io/post/easyvs/</link><pubDate>Mon, 09 Jan 2012 21:52:00 +0000</pubDate><guid>https://blog.qlf.io/post/easyvs/</guid><description>前前后后研究 VSX 也一个多月了，这两天终于做了一个小的插件 EasyVS。该插件目前只支持 VS2010，vs2008 的支持可能要过一段时间。还好我没有使用 MEF 的内容，所以移植到 vs2008 上应该困难不大。写这个插件的主要目的希望像 Resharper 那样提供许多实用的功能，让在 vs 中进行编码成为一种享受。
功能介绍 Quick Region 所谓快速 region 功能，就是在代码视图里面通过快捷键 Ctrl+Q,Ctrl+R 快捷键将代码自动分类到不同的 region 下，目前的 region 包括“变量”，“构造函数”，“事件”，“方法”，“属性”等。下面是一个例子演示，这个类是我从随便翻出来的，可以看到他的代码格式很乱。
下面通过 EasyVS 提供的快速 Region 功能进行代码的自动分类
整理后的代码
说白了就是让一些 region 的功能让程序帮你做了，省时省力。不过有一个缺点也很明显就是使用这个工具格式化出的 region 都一样，就缺少了自己特定的 region 了（原来自己的 reigon 会消失，以后的版本打算增加保留自己自定义 region 的功能）。
Less Tab 通过设置指定的 tab 数量，插件能够自动为您关闭多余的 Tab，减少 VS 内存占用，还您一个清爽的 VSTab 栏。例如，我在设置里面设置了只打开 5 个 Tab
那么以后在 VS 中你能同时打开的 tab 数不会超过 5 个。这样能够减少不知不觉中打开的 Tab 数，关闭不必要的 tab 以释放占用的内存。至于哪些 tab 会被关闭。你使用的越频繁的 tab 越不会被关闭。而很长时间没有使用的 tab 则关闭的几率会比较高。一句话，这个东西不会影响你正常的代码操作。</description></item><item><title>Android之旅---广播（BroadCast）</title><link>https://blog.qlf.io/post/android-broadcast/</link><pubDate>Sun, 06 Mar 2011 18:15:17 +0000</pubDate><guid>https://blog.qlf.io/post/android-broadcast/</guid><description>什么是广播 在 Android 中，Broadcast 是一种广泛运用的在应用程序之间传输信息的机制。我们拿广播电台来做个比方。我们平常使用收音机收音是这样的：许许多多不同的广播电台通过特定的频率来发送他们的内容，而我们用户只需要将频率调成和广播电台的一样就可以收听他们的内容了。Android 中的广播机制就和这个差不多的道理。
电台发送的内容是语音，而在 Android 中我们要发送的广播内容是一个 Intent。这个 Intent 中可以携带我们要传送的数据。
电台通过大功率的发射器发送内容，而在 Android 中则是通过 sendBroadcast 这个方法来发送（很形象的名字吧）。
用户通过调整到具体的电台频率接受电台的内容。而在 Android 中要接受广播中的内容则是通过注册一个 BroadCastReceiver 来接收的。只有发送广播的 action 和接收广播的 action 相同，接受者才能接受这个广播。
广播有什么用 其实，在什么是广播的第一句就已经说明了广播有什么用了。对了，笼统一点讲就是用来传输数据的。具体一点说就是：
实现了不同的程序之间的数据传输与共享，因为只要是和发送广播的 action 相同的接受者都能接受这个广播。典型的应用就是 android 自带的短信，电话等等广播，只要我们实现了他们的 action 的广播，那么我们就能接收他们的数据了，以便做出一些处理。比如说拦截系统短信，拦截骚扰电话等等 起到了一个通知的作用，比如在 service 中要通知主程序，更新主程序的 UI 等。因为 service 是没有界面的，所以不能直接获得主程序中的控件，这样我们就只能在主程序中实现一个广播接受者专门用来接受 service 发过来的数据和通知了。 实现广播 现在我们就来实现一个简单的广播程序。Android 提供了两种注册广播接受者的形式，分别是在程序中动态注册和在 xml 中指定。他们之间的区别就是作用的范围不同，程序动态注册的接收者只在程序运行过程中有效，而在 xml 注册的接收者不管你的程序有没有启动有会起作用。 首先介绍在程序中动态注册的方式。
动态注册方式 我们在程序中设置了三个按钮，分别是“注册广播”，“取消注册”和“发送广播”。然后每个按钮设置点击事件来完成广播的演示。最简单的项目的建立过程和按钮事件的建立我再这里就不罗嗦了，不会的可以下载下面的 DEMO 源码查看。直接看三个按钮的实现方式。 首先是注册广播的按钮事件代码：
private ReceiveBroadCast receiveBroadCast; //广播实例 public class RegisteLinster implements OnClickListener { @Override public void onClick(View view) { // 注册广播接收 receiveBroadCast = new ReceiveBroadCast(); IntentFilter filter = new IntentFilter(); filter.</description></item><item><title>QQ空间小精灵</title><link>https://blog.qlf.io/post/qzone-spirit/</link><pubDate>Sun, 13 Jun 2010 21:32:17 +0000</pubDate><guid>https://blog.qlf.io/post/qzone-spirit/</guid><description>没事儿写着玩的 QQ 空间辅助工具。
功能 QQ 空间留言 自动获得推荐炫酷代码。 自动保存、导入您的好友，方便下次使用。 高级空间代码编辑，自己实现炫酷代码，闪耀空间。 QQ 空间音乐 精选 QQ 空间音乐，随时随地享受。 提供音乐收藏，珍藏那些好的音乐，让她们时刻伴随你 看图：
下载 下载：QQ 空间小精灵
下载：QQ 空间小精灵-绿色版</description></item><item><title>跟我学做c#皮肤美化（五）</title><link>https://blog.qlf.io/post/charp-winform-skin-5/</link><pubDate>Fri, 23 Apr 2010 09:56:17 +0000</pubDate><guid>https://blog.qlf.io/post/charp-winform-skin-5/</guid><description>本篇主要解决上篇遗留的一些问题
先来回顾一下我们上次遗留的问题
消除图中不透明的地方 实现标题栏的拖动 实现窗体的最大化，最小化，关闭功能。 下面就来一个一个解决。
解决不透明的问题
首先为什么会有灰色的出现呢。不难想到这些灰色就是 Picturebox 的背景色。边角上的图片对粉红色透明了，但却露出了背景的颜色。知道了原因就好了解决了，就是我们需要将这一块的背景色给透明掉。有人说可以讲 picturebox 的背景色设置为透明的啊。不错，是可以，但整个窗体的背景色呢？picturebox 下面不还是有整个被覆盖的窗体的嘛！窗体是不能像用户控件那样背景色设置为透明的，不过却有一个属性 TransparencyKey 可以间接的为我们解决这个问题。这个属性的作用是这样的，当这个属性设置为某一种颜色后，那该窗体上的所有的这种颜色将都变为透明色。
所以我们只需将 TransparencyKey 的颜色和窗体的背景色设置成一样，那么背景色不就自动透明了嘛！在这里我们将所有控件的背景色和 TransparencyKey 都设置成系统里面的 Info 颜色（这个颜色你可以自己指定，不过不建议是原来的 Control 色，因为这样后你再添加一个普通的控件，那么这个控件的一部分也会被透明掉）
实现标题栏的拖动
因为我们的窗体是没有状态栏的，所以当我们想移动窗口的时候发现怎么也”移不动”(不是有个笑话的嘛“中国移不动“,呵呵)。要解决这个问题还是需要借助 API 来完成。那如何知道别人需要移动窗体呢？这里我们就通过 MouseDown 这个事件来判断。即如果用户在特定的区域内按下了鼠标左键，那么我们就认为用户需要移动客户端了。这个时候我们调用相应的 API 向系统通知（SendMessage）让系统做出响应。为了效果好一点，我们将状态栏那一行的所有的 MouseDown 事件都用这个方法。于是现在我们运行一下看看能否移动窗体。
很不错嘛！又是一个问题解决了，现在只要将右上方的三个按钮的功能完成那这个窗体就算基本完成了啦。好了，我们继续。
要处理按钮的事件，毫无疑问我们在设计模式中双击对应的按钮，然后处理。这里还要提一下的就是我们需要在这些事件的每个方法钱加一个 virtual 让这些个方法可以被重写。道理很简单，假如我按关闭按钮的时候不想其直接关闭而是先弹出对话框提醒一下用户怎么办呢？总不能让用这个控件的人再去修改这个皮肤控件吧，最好的办法就是可以让他们重写按钮的 click 事件，他们想干嘛干嘛，不想有其他的功能只要不重写就是了。
好了开始说最小化功能吧
很简单，一句话搞定：this.WindowState = FormWindowState.Minimized;然后是关闭按钮，还是一句话的事情：this.close();呵呵貌似这两个功能真简单那！原本最大化也不复杂的，可是遇到了前面说到的那个问题，我们就知道想点儿其他的办法啦。看代码：
当用户点击最大化按钮的时候我们先将最大化按钮上移隐藏，然后将还原按钮降下（还记得我们一开始给他设置的位置是-30 吗？），然后我们最大化之前就先记录窗体的大小和位置（就是最开始赋值的那四句话）信息便于后面的还原。接下来的四句就是咱们手动来制造一种窗体最大化的状态啦，首先位置肯定在左上角。然后大小应该就是用户电脑屏幕客户区的大小，这个大小我是用 Screen.PrimaryScreen.WorkingArea 这个函数得到的。状态设置完了我们只要改一下窗体的状态标识 st 为 stat.Max。然后当用户想还原的时候我们只要在 btres 的 click 的点击事件中做一下刚才那个动作的反就行了。怎么样,是不是也不难啊！Ok，最后看一下运行效果：
发现问题：
终于是做好了。不过假如你也实际跟我动手做出了一个，你或许会发现以下一些问题：
点击最大化的时候反应好像有点慢，意思就是大概要过个这个半秒钟才会最大化。 还有一个问题就是从最小化状态下恢复到最大化状态，窗体左上角会有闪烁现象(闪的实在太快了，没办法截图啊，大家可以应用下我下面上传的 DLL 运行下就知道了)。我们本来就是想美化窗口，但是如果这些个问题一来实在是给人感觉不好，甚至还不如不美化。在下一篇中我将会带领大家解决这个问题。 我们的窗体位置虽然能移动了，不过大小还不能拖动。 在下一篇中我会带领大家解决这些问题，敬请期待！</description></item><item><title>一个httpwebrequest异步下载的例子</title><link>https://blog.qlf.io/post/a-httpwebrequest-demo/</link><pubDate>Fri, 23 Apr 2010 09:47:17 +0000</pubDate><guid>https://blog.qlf.io/post/a-httpwebrequest-demo/</guid><description>最近经常要用到模拟网页的登录，网页的抓取。一开始都是用同步的方法获取，同步在请求量比较小的情况下还可以接受。但是比如我一下子请求上百个，上千个页面就显得力不从心了。昨天终于狠下心来研究了一下异步的获取方式。虽说没有同步的方法简单，不过效率上真的提高了很多。现在记下来，以便以后查阅吧。
namespace 异步调用方法 { class Program { static void Main(string[] args) { for (int i = 0; i &amp;lt; 1111; i++) { HttpWebRequest request = (HttpWebRequest)WebRequest.Create(&amp;quot;http://www.cnblogs.com/qianlifeng/&amp;quot;); request.BeginGetResponse(new AsyncCallback(OnResponse), request); Console.WriteLine(&amp;quot;请求&amp;quot; + i + &amp;quot;完成&amp;quot;); } Console.Read(); } static void OnResponse(IAsyncResult ar) { HttpWebRequest request = (HttpWebRequest)ar.AsyncState; HttpWebResponse response = (HttpWebResponse)request.EndGetResponse(ar); Stream stream = response.GetResponseStream(); StreamReader sr = new StreamReader(stream, Encoding.UTF8); Console.WriteLine( sr.ReadToEnd()); } } }</description></item><item><title>跟我学做c#皮肤美化（四）</title><link>https://blog.qlf.io/post/charp-winform-skin-4/</link><pubDate>Thu, 15 Apr 2010 13:04:17 +0000</pubDate><guid>https://blog.qlf.io/post/charp-winform-skin-4/</guid><description>这篇介绍窗体的制作
做了许多的用户控件，现在让我们换换口味，开始窗体的制作吧！这个窗体的制作可以说是整个美化中比较重要的一部分，因为她显示的是整个美化的窗体。而且内容也比较多，所以我会分几篇把她讲完，而且窗体制作的时候会和前面控件将的时候不一样，我不会在第一篇把最后的代码就放出来，而是希望做成跟着我一起一个版本一版本的完成不断的修改不断的发现问题并去完善。这也是我做这个时候的一个思路：先做一个大致的框架，然后在其基础上增加功能或者发现问题，最后完成功能和解决问题。不知道大家感觉这样是不是更好一点呢？
好了，不多说了，先看最终的效果图：
怎么样？是不是有点心动了？下面就正式开始吧！首先在以前的项目 QLFUI 上新建一个窗体(不是用户控件咯)并重新命名为 MainForm。如图：
接着来设置几个属性,如下：
FormBorderStyle:None Size:300,300 接下来就是用 picturebox 和 panel 来布局了。这一部分可能比较繁琐。首先总体介绍一下大概的布局。见图：
因为我们做的窗体是圆角的，所以窗体的四个角上(红色)我们会放上四个 picturebox。标题栏和状态栏(蓝色)会是两个 panel。二个边框线(绿色)是两个 picturebox。最后的主体部分（棕色）是一个 panel。说完了大体的布局，下面就来动手做啦。一个一个来:
左上角
Name:ptbtl Location:0,0 Size:10,31 上方的标题栏
Modifiers:Protected; Name:panelt Location:10,0 Size:280,31 右上角
Name:ptbtr Location:290,0 Size:10,31 左侧的边框线
Name:ptbml Location:0,31 Size:2,232 主窗体部分
Modifiers:Protected; BackgroundImageLayout:Stretch Name:panelm Location:2,31 Size:296,232 右侧的边框线
Name:ptbmr Location:298,31 Size:2,232 左下角
Name:ptbbl Location:0,263 Size:10,37 下方的状态栏
Modifiers:Protected; Name:panelb Location:10,263 Size:280,37 右下角
Name:ptbbr Location:290,263 Size:10,37 最后还有右上方的三个按钮可不要忘记了，注意按钮都是在 panelt 里面设置的而且这三个按钮都是我们前面做的按钮哦，终于派上用场啦！
最小化按钮
Caption:0 Name:btmin Location:180,0 Size:31,22 最大化按钮
Caption:0 Name:btmax Location:211,0 Size:31,22 关闭按钮</description></item><item><title>跟我学做c#皮肤美化（三）</title><link>https://blog.qlf.io/post/charp-winform-skin-3/</link><pubDate>Thu, 15 Apr 2010 12:58:17 +0000</pubDate><guid>https://blog.qlf.io/post/charp-winform-skin-3/</guid><description>这篇介绍 Checkbox 控件的制作
先看最终的效果图：
或许大家已经猜出来我这个 checkbox 是怎么实现的吧？不错，就是前面的框是一个图片，后面的文字是 label。经过前面 button 的讲解我想有能力的人完全可以单独制作出来。还不熟悉的现在就开始跟我一步一步的来。
打开上次的项目 QLFUI,新建一个名为 CheckBox 的用户控件。如图
同样的，我们先设置一下，使其看起来像一个 checkbox。具体设置如下：
CheckBox 控件
Size:70,13 MinimumSize:70,13 BackColor:Transparent 然后拖一个 picturebox 并设置以下属性：
Size:13,13 Location:0,0, BackgroundImageLayout:Stretch 再拖一个 label 上来设置以下属性：
AutoSize:falseLocation:15,0 Size:50:13 最终应该是这个样子：
好了，样子有了接下来就是编码了！还是一样，先贴代码，然后我一句一句解释：
代码 using System; using System.Collections.Generic; using System.ComponentModel; using System.Drawing; using System.Data; using System.Linq; using System.Text; using System.Windows.Forms; using System.Reflection; using System.Drawing.Imaging; namespace QLFUI { public partial class CheckBox : UserControl { #region 变量 Image _normal; Image _normalmove; Image _checkedmove; Image _checked; bool check; #endregion #region 属性 [Category(&amp;quot;QLFSkinDll&amp;quot;)] [Description(&amp;quot;控件是否被选中&amp;quot;)] public bool Checked { get { return check; } set { if (value == true) { pictureBox1.</description></item><item><title>跟我学做c#皮肤美化（二）</title><link>https://blog.qlf.io/post/charp-winform-skin-2/</link><pubDate>Tue, 13 Apr 2010 10:22:17 +0000</pubDate><guid>https://blog.qlf.io/post/charp-winform-skin-2/</guid><description>这篇介绍 Button 控件的制作
先来看看我们最终要做的效果图（分别对应普通、悬停、按下时的状态）：
下面就开始正式做。首先让我们新建一个控件库项目，命名为 QLFUI。如图：
然后将默认的 UserControl1 重命名为 Button。接下来，我们就要在这上面来做文章了。先来稍稍设置一下，让这个用户控件看起来更像一个按钮吧！
Button 的
Size: 78,30 BackgroundImageLayout:Stretch 然后拖一个 label 控件到这个用户控件上，并设置 label1 的属性为
AutoSize:false , Dock:fill, TextAlign:MiddleCenter, BackColor: Transparent, Font: 宋体, 9pt 这几个属性。好了，是不是开始像一个按钮了呢？
哦，差点忘了最后还要将整个控件（BUTTON）的背景色设置为 Trasparent 透明色。因为如果不设置成透明色那么透明的图片下面就会显示出 button 的背景色（默认灰色），不好看。好了，现在样子的已经大概有了，接下来就是编程了。先贴代码，然后我一个一个解释：
代码 [DefaultEvent(&amp;quot;Click&amp;quot;)] public partialclass Button: UserControl { #region 变量 //三种不同状态下的图片 Image _normalImage =null; Image _moveImage =null; Image _downImage =null; #endregion #region 属性 [Category(&amp;quot;QLFSkinDll&amp;quot;)] public ImageNormalImage { get { return_normalImage; } set { _normalImage = value; } } [Category(&amp;quot;QLFSkinDll&amp;quot;)] public ImageDownImage { get{ return _downImage; } set { _downImage = value; } } [Category(&amp;quot;QLFSkinDll&amp;quot;)] public ImageMoveImage { get{ return _moveImage; } set { _moveImage = value; } } [Category(&amp;quot;QLFSkinDll&amp;quot;)] public stringCaption { get{ returnthis.</description></item><item><title>跟我学做c#皮肤美化（一）</title><link>https://blog.qlf.io/post/charp-winform-skin/</link><pubDate>Tue, 13 Apr 2010 10:13:17 +0000</pubDate><guid>https://blog.qlf.io/post/charp-winform-skin/</guid><description>概述与导航 每每看着 QQ,360 等等那些软件漂亮的外衣时，你是不是总是在想我的软件什么时候才能穿上这么漂亮的外衣呢？不过现在当你看到这篇文章的时候不必再发出这样的疑问了，因为接下来我会带领大家一步一步”画出”这些漂亮的外衣！
在写这系列文章之前要感谢博客园的苏飞，我也是看来他的文章后才开始接触皮肤的制作的！我写的这系列文章中有和苏飞相同的地方，也有不同的地方。还有因为我想使这个系列的文章能使刚刚接触皮肤编程的初学者都能跟着我一步一步的实现皮肤的制作，所以我会讲解的很详细很详细。呵呵，不知道这点算不算和苏飞大哥的一点小小的区别呢？！另外我写的这一系列暂时还不会包括换肤功能在里面，而且控件的健壮性，功能的全面性上也可能有不足的地方，希望大家包涵，毕竟我也是刚刚接触皮肤制作这一方面的内容，写的不好或者难免有一些错误的地方还请大家包涵。当然，如果大家有好的建议或者是想和我交流这方面的内容，我也很乐意。
接下来所有的控件我都会编写在一个用户控件库 QLFUI 中，以后的软件中想要应用这些皮肤只要简单的继承或者使用控件就是了。整个控件库可以简单的分成两大类：用户控件类和窗体类。用户控件类就是普通的用户控件比如说 Button 控件，让其不再单调！窗体类就是写一个带有皮肤的窗体，以后其他的窗体只要继承一下就会自动带有了皮肤（多方便）。说了这么多还是先让大家看看最终做出来的效果图吧！
以后我讲解的内容大体是这个样子的：（因为时间原因可以会有有一些控件会增加或减少，不过我会尽量都讲解全的）
控件类 1. Button 控件的制作 2. CheckBox 控件的制作 3. TextBoxEx 控件的制作 窗体类： MainForm 窗体的制作(只要继承这个窗体基本上就能披上最简单的外衣了)
_ 窗体制作 1 _ 窗体制作 2 * 窗体制作 3 窗体换肤</description></item><item><title>回顾2009，展望2010</title><link>https://blog.qlf.io/post/goodbye-2009-and-hello-2010/</link><pubDate>Wed, 13 Jan 2010 23:31:00 +0000</pubDate><guid>https://blog.qlf.io/post/goodbye-2009-and-hello-2010/</guid><description>个人 2009 年度总结
回顾 2009 回想过去的 2009 年，基本可以分为 2 个阶段、3 件”大事”。
第一件”大事”就是年初买了属于自己的笔记本了。惠普的，CQ45。靠近 6000 左右，总体上来说还是比较满意的，不过最近感觉光驱不是很好。不过也没关系，反正也不怎么常用。之所以把这件事情定为第一个大事，是因为以后的事情基本上都少不了这台电脑了。 有了这台电脑，自然而然的就到了第一个阶段，时间段就是 09 年上半年把！带着好奇心与好玩心，我整整玩了半个学期，虽说没有将这些时间花费在游戏中，不过也是东学学西学学的。最后算是什么都没有学成，半个学期也就这样过去了。不过，对于这混过去的半个学期我倒也不是很遗憾，可以看成是一个过渡段吧。
紧接着就是第二件”大事”了，是在 6 月份吧应该。是件感情上的事情，这里就不再多说了。
这第三件“大事”就是我遇到了如鹏网。09 年暑假回家，因为家里没有宽带，所以就只好一个人捧着电脑无所事事。期间对批处理琢磨了一小段时间，做出了个“个人批处理工具集”，算是对学习批处理的一种肯定吧。不过说实话，现在还真忘记的差不多了。后来无意中碰到了如鹏网，被其“c 语言也能干大事”所吸引，从此爱上了编程，一发不可收拾。
有了这第三件“大事”，自然而然的就过渡到了第二个阶段了。时间段就是 09 年下半边：学习编程。
一开始，由于如鹏网的影响，开始接触 SDK 编程。包括暑假的一个月，前后总共大概学习了二个月左右吧！后来就开始接触.net 了。说道由 SDK 转 c#的原因，有以下几个方面吧：
.net 入门简单，适合新手学习。 热门语言，有与 java 平分的趋势。无论对就将来的工作还是什么，可能比搞纯 C 好些吧（纯粹个人当时的理解而已）。于是，.net 便成为我主攻的方向。到现在为止学习了三个多月了。也编写过小软件，网站，不过感觉都是很肤浅。只是知道表面级的应用却不知道内部的具体实现原理。就让以后慢慢去学习吧！ 展望 2010 我想还是同样分为两个阶段。
第一个阶段，缩小.net 学习范围，专攻 ASP.NET！从近来炒得比较热的云计算，再到谷歌马上就要发布的谷歌操作系统都在向我们传递这样一个消息：将来的天下必定会是网页应用的天下。随着科技的发展，带宽的增加将来只用一个浏览器来完成人们日常的操作将不会再是梦想。相比较已经风行了十几年的桌面软件来说，在未来网页应用肯定会超过桌面软件。经过上面的思考，我觉得还是应该专注 ASP.NET。另外从从一般的情况下来说，只有专注一门才会取得成功的，什么都弄是不行的。 学习网页，网站制作是一个比较漫长的过程。半年，一年肯定是学不好的。所以在 2010 年的上半年，我打算先学会 ASP.NET 控件的熟练应用以及相关的注意点、技巧什么的。起码要能运用这些知识写出个简单的系统出来。另外还有网页制作方面的技术，比如说 JavaScript，css，jQuery 等等。虽说网页制作不是程序员的事情，不过掌握了总是没错的。网页制作技术我想贯穿 2010 一整年来学习。
第二个阶段，2010 下半年自己录制一套 ASP.</description></item></channel></rss>