<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.79.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="https://blog.qlf.io/post/captcha-recognition-using-opencv/"><link rel=canonical href=https://blog.qlf.io/post/captcha-recognition-using-opencv/><link rel=preload href=/js/highlight.pack.js as=script><link rel=alternate type=application/atom+xml href=https://blog.qlf.ioindex.xml title="Scott Qian"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.qlf.io"},"articleSection":"post","name":"使用OpenCV进行简单验证码识别","headline":"使用OpenCV进行简单验证码识别","description":"最近对计算机视觉产生了点兴趣，具体来说应该是简单的图形识别方向。本文介绍了如何使用 OpenCV 进行简单的验证码识别。\n从头开始学习计算机视觉需要很强的数学功底，从图像预处理到图像匹配都需要用到数学知识，这对于我们这种初学者来说绝对是道很大很大很大很大\u0026hellip;..很大的门槛（原谅我对数学敬畏!_!）。不过，不要灰心，我们还有神器OpenCV。OpenCV 是一套开源的计算机视觉库，他封装了许多计算机视觉处理中常用的方法。在我们这边文章中，我们主要用到了他的阈值处理，轮廓查找，KNN 分类器等等。\n先看成品： http:\/\/nbviewer.ipython.org\/gist\/qianlifeng\/95023d6c8ce8b28518b8\n我摘一些主要的代码片段介绍一下：\n原始图像：\n所有的验证码处理一般都会先对图像进行一些预处理，包括去除噪点，灰度化，二值化，去除干扰线等等。二值化是为了降低图片的维度，从原来的 RGBA 变为只有 0 和 1 的一维数组。我们使用 cvtColor 进行灰度化处理。\ngray = cv2.cvtColor(im,cv2.COLOR_BGR2GRAY) 接着去噪，简单的去噪原理如下。我们会设置一个阈值，高于这个阈值的点变为黑色，低于的变成白色。（这里使用的是名为自适应阈值的去噪方法，效果好一点）\nthreshold = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY, 11, 40) 到这边图像预处理基本已经差不多了，剩下来就是寻找里面的图像轮廓，进行切图。\n(cnts, _) = cv2.findContours(ts.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) 这句话会找出图片给里面所有的轮廓信息，当然里面有很多无用的轮廓，比如 0 这个数字，他会找出两个轮廓出来。一个是 0 的外圈，一个是 0 的内圈。我们还需要一些简单的代码去除这些多余的轮廓。\ncmax = 100 cmin = 20 cts = [] for item in cnts: if cmin \u0026lt; len(item) \u0026lt; cmax: (x,y,w,h) = cv2.boundingRect(item) cts.append((x,y,w,h)) 未完待续!","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2014","datePublished":"2014-06-29 18:55:17 \u002b0000 UTC","dateModified":"2014-06-29 18:55:17 \u002b0000 UTC","url":"https:\/\/blog.qlf.io\/post\/captcha-recognition-using-opencv\/","keywords":[]}</script><title>使用OpenCV进行简单验证码识别 - Scott Qian</title><meta property="og:title" content="使用OpenCV进行简单验证码识别 - Scott Qian"><meta property="og:type" content="article"><meta property="og:description" content="最近对计算机视觉产生了点兴趣，具体来说应该是简单的图形识别方向。本文介绍了如何使用 OpenCV 进行简单的验证码识别。
从头开始学习计算机视觉需要很强的数学功底，从图像预处理到图像匹配都需要用到数学知识，这对于我们这种初学者来说绝对是道很大很大很大很大&mldr;..很大的门槛（原谅我对数学敬畏!_!）。不过，不要灰心，我们还有神器OpenCV。OpenCV 是一套开源的计算机视觉库，他封装了许多计算机视觉处理中常用的方法。在我们这边文章中，我们主要用到了他的阈值处理，轮廓查找，KNN 分类器等等。
先看成品： http://nbviewer.ipython.org/gist/qianlifeng/95023d6c8ce8b28518b8
我摘一些主要的代码片段介绍一下：
原始图像：
所有的验证码处理一般都会先对图像进行一些预处理，包括去除噪点，灰度化，二值化，去除干扰线等等。二值化是为了降低图片的维度，从原来的 RGBA 变为只有 0 和 1 的一维数组。我们使用 cvtColor 进行灰度化处理。
gray = cv2.cvtColor(im,cv2.COLOR_BGR2GRAY) 接着去噪，简单的去噪原理如下。我们会设置一个阈值，高于这个阈值的点变为黑色，低于的变成白色。（这里使用的是名为自适应阈值的去噪方法，效果好一点）
threshold = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY, 11, 40) 到这边图像预处理基本已经差不多了，剩下来就是寻找里面的图像轮廓，进行切图。
(cnts, _) = cv2.findContours(ts.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) 这句话会找出图片给里面所有的轮廓信息，当然里面有很多无用的轮廓，比如 0 这个数字，他会找出两个轮廓出来。一个是 0 的外圈，一个是 0 的内圈。我们还需要一些简单的代码去除这些多余的轮廓。
cmax = 100 cmin = 20 cts = [] for item in cnts: if cmin < len(item) < cmax: (x,y,w,h) = cv2.boundingRect(item) cts.append((x,y,w,h)) 未完待续!"><meta name=description content="最近对计算机视觉产生了点兴趣，具体来说应该是简单的图形识别方向。本文介绍了如何使用 OpenCV 进行简单的验证码识别。
从头开始学习计算机视觉需要很强的数学功底，从图像预处理到图像匹配都需要用到数学知识，这对于我们这种初学者来说绝对是道很大很大很大很大&mldr;..很大的门槛（原谅我对数学敬畏!_!）。不过，不要灰心，我们还有神器OpenCV。OpenCV 是一套开源的计算机视觉库，他封装了许多计算机视觉处理中常用的方法。在我们这边文章中，我们主要用到了他的阈值处理，轮廓查找，KNN 分类器等等。
先看成品： http://nbviewer.ipython.org/gist/qianlifeng/95023d6c8ce8b28518b8
我摘一些主要的代码片段介绍一下：
原始图像：
所有的验证码处理一般都会先对图像进行一些预处理，包括去除噪点，灰度化，二值化，去除干扰线等等。二值化是为了降低图片的维度，从原来的 RGBA 变为只有 0 和 1 的一维数组。我们使用 cvtColor 进行灰度化处理。
gray = cv2.cvtColor(im,cv2.COLOR_BGR2GRAY) 接着去噪，简单的去噪原理如下。我们会设置一个阈值，高于这个阈值的点变为黑色，低于的变成白色。（这里使用的是名为自适应阈值的去噪方法，效果好一点）
threshold = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY, 11, 40) 到这边图像预处理基本已经差不多了，剩下来就是寻找里面的图像轮廓，进行切图。
(cnts, _) = cv2.findContours(ts.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) 这句话会找出图片给里面所有的轮廓信息，当然里面有很多无用的轮廓，比如 0 这个数字，他会找出两个轮廓出来。一个是 0 的外圈，一个是 0 的内圈。我们还需要一些简单的代码去除这些多余的轮廓。
cmax = 100 cmin = 20 cts = [] for item in cnts: if cmin < len(item) < cmax: (x,y,w,h) = cv2.boundingRect(item) cts.append((x,y,w,h)) 未完待续!"><meta property="og:locale" content><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml title="Scott Qian"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class=post id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>Scott Qian</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>使用OpenCV进行简单验证码识别</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2014-06-29 18:55:17 UTC">29 Jun 2014</time></div><div class=col-xs-6></div></div></header><div class="post-content markdown-body"><p>最近对计算机视觉产生了点兴趣，具体来说应该是简单的图形识别方向。本文介绍了如何使用 OpenCV 进行简单的验证码识别。</p><p>从头开始学习计算机视觉需要很强的数学功底，从图像预处理到图像匹配都需要用到数学知识，这对于我们这种初学者来说绝对是道很大很大很大很大&mldr;..很大的门槛（原谅我对数学敬畏!_!）。不过，不要灰心，我们还有神器<a href=http://opencv.org/>OpenCV</a>。OpenCV 是一套开源的计算机视觉库，他封装了许多计算机视觉处理中常用的方法。在我们这边文章中，我们主要用到了他的阈值处理，轮廓查找，KNN 分类器等等。</p><p>先看成品：
<a href=http://nbviewer.ipython.org/gist/qianlifeng/95023d6c8ce8b28518b8>http://nbviewer.ipython.org/gist/qianlifeng/95023d6c8ce8b28518b8</a><br>我摘一些主要的代码片段介绍一下：</p><p>原始图像：<br></p><p>所有的验证码处理一般都会先对图像进行一些预处理，包括去除噪点，灰度化，二值化，去除干扰线等等。二值化是为了降低图片的维度，从原来的 RGBA 变为只有 0 和 1 的一维数组。我们使用 cvtColor 进行灰度化处理。</p><pre><code>gray = cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)
</code></pre><p></p><p>接着去噪，简单的去噪原理如下。我们会设置一个阈值，高于这个阈值的点变为黑色，低于的变成白色。（这里使用的是名为自适应阈值的去噪方法，效果好一点）</p><pre><code>threshold = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY, 11, 40)
</code></pre><p></p><p>到这边图像预处理基本已经差不多了，剩下来就是寻找里面的图像轮廓，进行切图。</p><pre><code>(cnts, _) = cv2.findContours(ts.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)
</code></pre><p>这句话会找出图片给里面所有的轮廓信息，当然里面有很多无用的轮廓，比如 0 这个数字，他会找出两个轮廓出来。一个是 0 的外圈，一个是 0 的内圈。我们还需要一些简单的代码去除这些多余的轮廓。</p><pre><code>cmax = 100
cmin = 20
cts = []
for item in cnts:
    if cmin &lt; len(item) &lt; cmax:
        (x,y,w,h) = cv2.boundingRect(item)
        cts.append((x,y,w,h))
</code></pre><p>未完待续!</p></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=post-comments><div id=disqus_thread></div><script>window.addEventListener("load",()=>{(function(){var d=document,s=d.createElement("script");s.src="https://scottqian.disqus.com/embed.js";s.setAttribute("data-timestamp",+new Date());(d.head||d.body).appendChild(s);})();});</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div><div class=site-footer><div class=site-footer-item><a href=https://github.com/qianlifeng target=_blank>Github</a></div></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>