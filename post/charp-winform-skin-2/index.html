<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.79.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="https://blog.qlf.io/post/charp-winform-skin-2/"><link rel=canonical href=https://blog.qlf.io/post/charp-winform-skin-2/><link rel=preload href=/js/highlight.pack.js as=script><link rel=alternate type=application/atom+xml href=https://blog.qlf.ioindex.xml title="Scott Qian"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.qlf.io"},"articleSection":"post","name":"跟我学做c#皮肤美化（二）","headline":"跟我学做c#皮肤美化（二）","description":"这篇介绍 Button 控件的制作\n先来看看我们最终要做的效果图（分别对应普通、悬停、按下时的状态）：\n下面就开始正式做。首先让我们新建一个控件库项目，命名为 QLFUI。如图：\n然后将默认的 UserControl1 重命名为 Button。接下来，我们就要在这上面来做文章了。先来稍稍设置一下，让这个用户控件看起来更像一个按钮吧！\nButton 的\nSize: 78,30 BackgroundImageLayout:Stretch 然后拖一个 label 控件到这个用户控件上，并设置 label1 的属性为\nAutoSize:false , Dock:fill, TextAlign:MiddleCenter, BackColor: Transparent, Font: 宋体, 9pt 这几个属性。好了，是不是开始像一个按钮了呢？\n哦，差点忘了最后还要将整个控件（BUTTON）的背景色设置为 Trasparent 透明色。因为如果不设置成透明色那么透明的图片下面就会显示出 button 的背景色（默认灰色），不好看。好了，现在样子的已经大概有了，接下来就是编程了。先贴代码，然后我一个一个解释：\n代码 [DefaultEvent(\u0026quot;Click\u0026quot;)] public partialclass Button: UserControl { #region 变量 \/\/三种不同状态下的图片 Image _normalImage =null; Image _moveImage =null; Image _downImage =null; #endregion #region 属性 [Category(\u0026quot;QLFSkinDll\u0026quot;)] public ImageNormalImage { get { return_normalImage; } set { _normalImage = value; } } [Category(\u0026quot;QLFSkinDll\u0026quot;)] public ImageDownImage { get{ return _downImage; } set { _downImage = value; } } [Category(\u0026quot;QLFSkinDll\u0026quot;)] public ImageMoveImage { get{ return _moveImage; } set { _moveImage = value; } } [Category(\u0026quot;QLFSkinDll\u0026quot;)] public stringCaption { get{ returnthis.","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2010","datePublished":"2010-04-13 10:22:17 \u002b0000 UTC","dateModified":"2010-04-13 10:22:17 \u002b0000 UTC","url":"https:\/\/blog.qlf.io\/post\/charp-winform-skin-2\/","keywords":[]}</script><title>跟我学做c#皮肤美化（二） - Scott Qian</title><meta property="og:title" content="跟我学做c#皮肤美化（二） - Scott Qian"><meta property="og:type" content="article"><meta property="og:description" content="这篇介绍 Button 控件的制作
先来看看我们最终要做的效果图（分别对应普通、悬停、按下时的状态）：
下面就开始正式做。首先让我们新建一个控件库项目，命名为 QLFUI。如图：
然后将默认的 UserControl1 重命名为 Button。接下来，我们就要在这上面来做文章了。先来稍稍设置一下，让这个用户控件看起来更像一个按钮吧！
Button 的
Size: 78,30 BackgroundImageLayout:Stretch 然后拖一个 label 控件到这个用户控件上，并设置 label1 的属性为
AutoSize:false , Dock:fill, TextAlign:MiddleCenter, BackColor: Transparent, Font: 宋体, 9pt 这几个属性。好了，是不是开始像一个按钮了呢？
哦，差点忘了最后还要将整个控件（BUTTON）的背景色设置为 Trasparent 透明色。因为如果不设置成透明色那么透明的图片下面就会显示出 button 的背景色（默认灰色），不好看。好了，现在样子的已经大概有了，接下来就是编程了。先贴代码，然后我一个一个解释：
代码 [DefaultEvent(&#34;Click&#34;)] public partialclass Button: UserControl { #region 变量 //三种不同状态下的图片 Image _normalImage =null; Image _moveImage =null; Image _downImage =null; #endregion #region 属性 [Category(&#34;QLFSkinDll&#34;)] public ImageNormalImage { get { return_normalImage; } set { _normalImage = value; } } [Category(&#34;QLFSkinDll&#34;)] public ImageDownImage { get{ return _downImage; } set { _downImage = value; } } [Category(&#34;QLFSkinDll&#34;)] public ImageMoveImage { get{ return _moveImage; } set { _moveImage = value; } } [Category(&#34;QLFSkinDll&#34;)] public stringCaption { get{ returnthis."><meta name=description content="这篇介绍 Button 控件的制作
先来看看我们最终要做的效果图（分别对应普通、悬停、按下时的状态）：
下面就开始正式做。首先让我们新建一个控件库项目，命名为 QLFUI。如图：
然后将默认的 UserControl1 重命名为 Button。接下来，我们就要在这上面来做文章了。先来稍稍设置一下，让这个用户控件看起来更像一个按钮吧！
Button 的
Size: 78,30 BackgroundImageLayout:Stretch 然后拖一个 label 控件到这个用户控件上，并设置 label1 的属性为
AutoSize:false , Dock:fill, TextAlign:MiddleCenter, BackColor: Transparent, Font: 宋体, 9pt 这几个属性。好了，是不是开始像一个按钮了呢？
哦，差点忘了最后还要将整个控件（BUTTON）的背景色设置为 Trasparent 透明色。因为如果不设置成透明色那么透明的图片下面就会显示出 button 的背景色（默认灰色），不好看。好了，现在样子的已经大概有了，接下来就是编程了。先贴代码，然后我一个一个解释：
代码 [DefaultEvent(&#34;Click&#34;)] public partialclass Button: UserControl { #region 变量 //三种不同状态下的图片 Image _normalImage =null; Image _moveImage =null; Image _downImage =null; #endregion #region 属性 [Category(&#34;QLFSkinDll&#34;)] public ImageNormalImage { get { return_normalImage; } set { _normalImage = value; } } [Category(&#34;QLFSkinDll&#34;)] public ImageDownImage { get{ return _downImage; } set { _downImage = value; } } [Category(&#34;QLFSkinDll&#34;)] public ImageMoveImage { get{ return _moveImage; } set { _moveImage = value; } } [Category(&#34;QLFSkinDll&#34;)] public stringCaption { get{ returnthis."><meta property="og:locale" content><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml title="Scott Qian"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class=post id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>Scott Qian</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>跟我学做c#皮肤美化（二）</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2010-04-13 10:22:17 UTC">13 Apr 2010</time></div><div class=col-xs-6></div></div></header><div class="post-content markdown-body"><p>这篇介绍 Button 控件的制作</p><p>先来看看我们最终要做的效果图（分别对应普通、悬停、按下时的状态）：</p><p><img src=http://ww3.sinaimg.cn/large/5d7c1fa4gw1elx1xew8pqj20aa01i0sm.jpg alt></p><p>下面就开始正式做。首先让我们新建一个控件库项目，命名为 QLFUI。如图：</p><p><img src=http://ww4.sinaimg.cn/large/5d7c1fa4gw1elx1y3bnlaj20sd0izwic.jpg alt></p><p>然后将默认的 UserControl1 重命名为 Button。接下来，我们就要在这上面来做文章了。先来稍稍设置一下，让这个用户控件看起来更像一个按钮吧！</p><p>Button 的</p><pre><code>Size: 78,30
BackgroundImageLayout:Stretch
</code></pre><p>然后拖一个 label 控件到这个用户控件上，并设置 label1 的属性为</p><pre><code>AutoSize:false ,
Dock:fill,
TextAlign:MiddleCenter,
BackColor: Transparent,
Font: 宋体, 9pt
</code></pre><p>这几个属性。好了，是不是开始像一个按钮了呢？</p><p>哦，差点忘了最后还要将整个控件（BUTTON）的背景色设置为 Trasparent 透明色。因为如果不设置成透明色那么透明的图片下面就会显示出 button 的背景色（默认灰色），不好看。好了，现在样子的已经大概有了，接下来就是编程了。先贴代码，然后我一个一个解释：</p><pre><code>代码

 [DefaultEvent(&quot;Click&quot;)]
   public partialclass Button: UserControl
   {
        #region 变量

       //三种不同状态下的图片
       Image _normalImage =null;
       Image _moveImage =null;
       Image _downImage =null;

        #endregion

        #region 属性

       [Category(&quot;QLFSkinDll&quot;)]
       public ImageNormalImage
       {
            get
            {
                return_normalImage;

            }
            set
            {
                _normalImage = value;
            }
       }

       [Category(&quot;QLFSkinDll&quot;)]
       public ImageDownImage
       {
            get{ return _downImage; }
            set
            {
                _downImage = value;
            }
       }

       [Category(&quot;QLFSkinDll&quot;)]
       public ImageMoveImage
       {
            get{ return _moveImage; }
            set
            {
                _moveImage = value;
            }
       }

       [Category(&quot;QLFSkinDll&quot;)]
       public stringCaption
       {
            get{ returnthis.label1.Text;}   //控件运行时会自动运行get方法得到值
set
            {
                this.label1.Text= value;
            }
       }

        #endregion

        #region 构造函数

       public Button()
       {
            this.SetStyle(ControlStyles.AllPaintingInWmPaint | ControlStyles.OptimizedDoubleBuffer, true);
            //默认的是自带的图片样式，如果使用该按钮则必须手工指定当前按钮你想要的背景图片
            _normalImage = Image.FromStream(Assembly.GetExecutingAssembly().GetManifestResourceStream(@&quot;QLFUI.Res.button.btnnomal.bmp&quot;));
            _moveImage = Image.FromStream(Assembly.GetExecutingAssembly().GetManifestResourceStream(@&quot;QLFUI.Res.button.btnfore.bmp&quot;));
            _downImage = Image.FromStream(Assembly.GetExecutingAssembly().GetManifestResourceStream(@&quot;QLFUI.Res.button.btndown.bmp&quot;));
            MakeTransparent(_normalImage);
            MakeTransparent(_moveImage);
            MakeTransparent(_downImage);
            InitializeComponent();
            this.BackgroundImage= _normalImage;
       }

        #endregion

        #region 辅助函数

       private voidMakeTransparent(Image image)
       {
            Bitmapbitmap = image as Bitmap;
            bitmap.MakeTransparent(Color.FromArgb(255, 0, 255));
       }

        #endregion

        #region 事件

       private voidlabel1_MouseEnter(object sender, EventArgs e)
       {
            this.BackgroundImage= _moveImage;
       }

       private voidlabel1_MouseDown(object sender, MouseEventArgs e)
       {
            this.BackgroundImage= _downImage;
       }

       private voidlabel1_MouseLeave(object sender, EventArgs e)
       {
            this.BackgroundImage= _normalImage;
       }

       private voidlabel1_MouseUp(object sender, MouseEventArgs e)
       {
            this.BackgroundImage= _normalImage;
       }


       private voidlabel1_Click(object sender, EventArgs e)
       {
            this.OnClick(e);
       }

        #endregion

    }
</code></pre><p><strong>先看第一句：</strong><code>[DefaultEvent("Click")]</code>，这句话是什么意思呢？我们知道平常我们拖一个按钮后，在设计模式下双击这个按钮就会自动产生这个按钮的 Click 事件。这个默认的 Click 事件从哪里来的呢，毫无疑问就是<code>[DefaultEvent("Click"</code>)]这一句来设置的啦！这里默认的是 Click 事件，如果写成<code>[DefaultEvent("MouseEnter")]</code>就是 MouseEnter 事件啦！</p><p>接下来的四句分别定义了按钮三种不同状态下的 bitmap。</p><p>下面的四个属性分别是三种不同状态下 Image 的属性和按钮的文字属性 Caption,大家一看应该就明白。具体要解释的就是<code>[Category("QLFSkinDll")]</code>。这句话的意思是将这些属性分类，看个图片大家就都明白了:以后在项目中设置属性时，我们定义的属性就自动分类在 QLFSkinDll 下面了。</p><p><strong>接下来是构造函数</strong>：public Button(){}中的内容。</p><p>第一句是开始了窗体的双缓冲。双缓冲的意思就是现在内容中将图像画好了然后再显示到界面上去。在 c#中图像一多最怕的就是图像闪烁的问题，开启了双缓冲虽说不能完全避免图像闪烁，但起码也能有一定的效果，我们就先开着吧^ ^！</p><p>接下来的三句就是给三个状态的图像赋值了，这里我是把图像嵌入进来了，并没有放置在外部。要应用嵌入的资源分两步走：第一步在项目中点击图片的属性，然后将“生成操作”改为嵌入的资源。</p><p><img src=http://ww3.sinaimg.cn/large/5d7c1fa4gw1elx2c1rs6zj207q0ietao.jpg alt></p><p>第二步应用就是我们用到的代码啦：</p><pre><code>Assembly.GetExecutingAssembly().GetManifestResourceStream(@&quot;QLFUI.Res.button.btnnomal.bmp&quot;)
</code></pre><p>这句话前面的照写，后面的路径规则是“命名空间+文件夹名+你的文件名+文件名后缀”，当然如果你的文件直接放在项目下就没有文件夹名了。聪明的大家应该明白吧？呵呵！其中我们要用到的文件大家可以从我给的项目例子中复制。接下来的</p><pre><code>MakeTransparent(_normalImage);
MakeTransparent(_moveImage);
MakeTransparent(_downImage);
</code></pre><p>三句先不看，可以注释掉，下面会讲解它的作用的。</p><p>第八句<code>InitializeComponent()</code>是系统自带的初始化控件一些代码，我们不用去管它。最后一句<code>this.BackgroundImage =_normalImage;</code>就是设置按钮的其实的图片的样子啦！</p><p>好啦，写了这么久，咱们还是先来看看能运行出个什么样子出来吧！看看目前的状态下，它离我们的目标还差多远！见图：</p><p><img src=http://ww3.sinaimg.cn/large/5d7c1fa4gw1elx2dq5591j20co0dggmq.jpg alt></p><p>从图中我们可以看到明显的一个问题，就是按钮的边缘有粉红色。而且如果你也正好做到这里也会发现鼠标经过按钮时，按钮没有任何反应（废话，我们还什么都没做呢）。</p><p><strong>好了，接下来就有目标了，解决这两个问题我们这个按钮美化的就差不多了！</strong></p><p>先来解决第一个问题，去掉粉红色。我们需要用到 Bitmap 的一个函数 MakeTransparent(Color),这个函数的作用是使指定的颜色对 Bitmap 透明。也就是说我们只要将这个函数的 Color 设置为我们需要去掉的粉红色不就行了?!</p><p>继续看代码，我们先写一个函数 private void MakeTransparent(Imageimage)，这个函数的作用就是将传进来的图片的指定的颜色进行透明处理。函数里就两句话，第一句话先将 Image 转为 Bitmap。第二句话就是进行透明处理，这里的 Color.FromArgb(255, 0, 255)就是我们要去的粉红色啦。那什么时候进行去色呢？毫无疑问，当然是在给三种状态赋值后紧接着就去色啦！所以我们在构造函数中的 5,6,7 句加上透明处理。(倒过来讲这个作用，大家习惯不习惯呢？)好了，现在我们再来运行一下：看图：</p><p><img src=http://ww2.sinaimg.cn/large/5d7c1fa4gw1elx2ea9cuzj20cm0dd75e.jpg alt></p><p>呵呵，正如预料的那样，粉红色没有了（图中的灰色其实是透明的，只要在另外一个项目中引用一下就知道了），第一个问题解决！</p><p>再来看第二个问题，要实现按钮的变色肯定是跟鼠标的事件相关啦，比如说鼠标一进入按钮的范围之内我们就让按钮的背景改变，按下和离开按钮的时候也响应的改变背景。所以我们用到这四个事件（注意，事件都是 label1 的事件，因为我们将 label 覆盖在按钮上，所以我们点击的其实是 label1）：MouseEnter，MouseDown, MouseLeave, MouseUp。具体的事件里面执行的代码也很简单，就是更换按钮的背景图片。好了，让我们再运行一下看看效果：</p><p><img src=http://ww1.sinaimg.cn/large/5d7c1fa4gw1elx2eosdpaj20cl0db0tt.jpg alt></p><p>OK!两个问题都解决了，我们的按钮运行的好像也很正常！鼠标进入，移出，按下的时候也会变换背景！但是，如果你另外建一个项目，并双击产生点击事件并编写相应代码时就会发现点击事件没作用了。多么郁闷的一件事情啊，点击事件都没作用了，我们还要这个按钮干嘛啊！别急，让我们来解决它。首先要明白的就是我们在其他项目中引用的这个的 button 控件的点击事件是整个用户控件的点击事件（还记得我们在整个 button 类的上方设置了默认的点击事件吗？），而当我们去点击按钮时我们实际点击的只是 label1。问题很明了了，我们点击的是 label1，设置的却是整个用户控件的事件，当然触发不了事件了。既然问题已经搞明白了，下面就去解决它。继续看代码：</p><p>既然我们点击的是 label1 那么我们就在 label1 的点击事件中做文章，如代码所示，我们在 label1 的点击事件中触发了整个类（this）的 onclick 事件，然后这个 onclick 会去找相应的类的 click 事件，就是我们在其他项目中直接双击的那个事件啦！</p><p>OK，至此这个按钮空间的美化就做好了看看效果吧！</p><p><img src=http://ww1.sinaimg.cn/large/5d7c1fa4gw1elx2fic2y5j20gl0aw74r.jpg alt></p></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=post-comments><div id=disqus_thread></div><script>window.addEventListener("load",()=>{(function(){var d=document,s=d.createElement("script");s.src="https://scottqian.disqus.com/embed.js";s.setAttribute("data-timestamp",+new Date());(d.head||d.body).appendChild(s);})();});</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div><div class=site-footer><div class=site-footer-item><a href=https://github.com/qianlifeng target=_blank>Github</a></div></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>