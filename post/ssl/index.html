<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.79.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="https://blog.qlf.io/post/ssl/"><link rel=canonical href=https://blog.qlf.io/post/ssl/><link rel=preload href=/js/highlight.pack.js as=script><link rel=alternate type=application/atom+xml href=https://blog.qlf.ioindex.xml title="Scott Qian"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.qlf.io"},"articleSection":"post","name":"SSL协议运行机制","headline":"SSL协议运行机制","description":"最近两天在研究关于安全方面的东西，必不可少的需要了解一下 Https\/SSL 的通信原理，在这里将了解的结果做个总结。\n首先，SSL 的通信过程大体可以分为两个阶段：密钥交换（也有的称之为握手）和正式传输。\n密钥交换\/握手阶段   首先客户端像服务器发送加密连接请求\n  服务端接收到请求之后，给客户端发送包含 Public Key 的证书\n  这里之所以不直接发送 Public Key，而是将公钥放在证书中发送给客户端，是因为这样可以防止 Public Key 被篡改。只要证书是可信的，那么 Public Key 就是可信的。另外这个证书通常又叫做 X.509 证书，这个证书由 CA(Certificate Authority)颁发。\n客户端校验证书的合法性。然后客户端生成一个对称加密密钥。并用服务端发送过来的 Public Key 进行加密，最后将加密过后的密钥发送给服务器端    为什么要多生成一个密钥进行加密传输，而不是直接使用 Public key 进行加密？\n非对称加密，比较安全，但是加解密大量数据的时候性能不行。而对称加密性能好，但是双方密钥都一样，安全性不好。所以 SSL 采用的方法是仅使用非对称加密来加密对称加密的密钥，然后再用这个加密过的密钥加密传输数据。\n  如何进行证书合法性校验？\n客户端，一般是浏览器，会查找计算机上面的可信证书链，确保发过来的证书是受信任的证书。\n  服务端用 Private Key 解密发送过来的密钥  这样双方就在一种可信任的环境下获得了加解密数据的密钥，以后所有的通信数据都通过这个密钥来进行加解密。\n传输阶段 经过上面的握手阶段，双方都获得了加密密钥后，直接使用 HTTP 层的协议传输加密过后的数据即可。","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2015","datePublished":"2015-05-05 14:47:17 \u002b0000 UTC","dateModified":"2015-05-05 14:47:17 \u002b0000 UTC","url":"https:\/\/blog.qlf.io\/post\/ssl\/","keywords":[]}</script><title>SSL协议运行机制 - Scott Qian</title><meta property="og:title" content="SSL协议运行机制 - Scott Qian"><meta property="og:type" content="article"><meta property="og:description" content="最近两天在研究关于安全方面的东西，必不可少的需要了解一下 Https/SSL 的通信原理，在这里将了解的结果做个总结。
首先，SSL 的通信过程大体可以分为两个阶段：密钥交换（也有的称之为握手）和正式传输。
密钥交换/握手阶段   首先客户端像服务器发送加密连接请求
  服务端接收到请求之后，给客户端发送包含 Public Key 的证书
  这里之所以不直接发送 Public Key，而是将公钥放在证书中发送给客户端，是因为这样可以防止 Public Key 被篡改。只要证书是可信的，那么 Public Key 就是可信的。另外这个证书通常又叫做 X.509 证书，这个证书由 CA(Certificate Authority)颁发。
客户端校验证书的合法性。然后客户端生成一个对称加密密钥。并用服务端发送过来的 Public Key 进行加密，最后将加密过后的密钥发送给服务器端    为什么要多生成一个密钥进行加密传输，而不是直接使用 Public key 进行加密？
非对称加密，比较安全，但是加解密大量数据的时候性能不行。而对称加密性能好，但是双方密钥都一样，安全性不好。所以 SSL 采用的方法是仅使用非对称加密来加密对称加密的密钥，然后再用这个加密过的密钥加密传输数据。
  如何进行证书合法性校验？
客户端，一般是浏览器，会查找计算机上面的可信证书链，确保发过来的证书是受信任的证书。
  服务端用 Private Key 解密发送过来的密钥  这样双方就在一种可信任的环境下获得了加解密数据的密钥，以后所有的通信数据都通过这个密钥来进行加解密。
传输阶段 经过上面的握手阶段，双方都获得了加密密钥后，直接使用 HTTP 层的协议传输加密过后的数据即可。"><meta name=description content="最近两天在研究关于安全方面的东西，必不可少的需要了解一下 Https/SSL 的通信原理，在这里将了解的结果做个总结。
首先，SSL 的通信过程大体可以分为两个阶段：密钥交换（也有的称之为握手）和正式传输。
密钥交换/握手阶段   首先客户端像服务器发送加密连接请求
  服务端接收到请求之后，给客户端发送包含 Public Key 的证书
  这里之所以不直接发送 Public Key，而是将公钥放在证书中发送给客户端，是因为这样可以防止 Public Key 被篡改。只要证书是可信的，那么 Public Key 就是可信的。另外这个证书通常又叫做 X.509 证书，这个证书由 CA(Certificate Authority)颁发。
客户端校验证书的合法性。然后客户端生成一个对称加密密钥。并用服务端发送过来的 Public Key 进行加密，最后将加密过后的密钥发送给服务器端    为什么要多生成一个密钥进行加密传输，而不是直接使用 Public key 进行加密？
非对称加密，比较安全，但是加解密大量数据的时候性能不行。而对称加密性能好，但是双方密钥都一样，安全性不好。所以 SSL 采用的方法是仅使用非对称加密来加密对称加密的密钥，然后再用这个加密过的密钥加密传输数据。
  如何进行证书合法性校验？
客户端，一般是浏览器，会查找计算机上面的可信证书链，确保发过来的证书是受信任的证书。
  服务端用 Private Key 解密发送过来的密钥  这样双方就在一种可信任的环境下获得了加解密数据的密钥，以后所有的通信数据都通过这个密钥来进行加解密。
传输阶段 经过上面的握手阶段，双方都获得了加密密钥后，直接使用 HTTP 层的协议传输加密过后的数据即可。"><meta property="og:locale" content><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml title="Scott Qian"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class=post id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>Scott Qian</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>SSL协议运行机制</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2015-05-05 14:47:17 UTC">05 May 2015</time></div><div class=col-xs-6></div></div></header><div class="post-content markdown-body"><p>最近两天在研究关于安全方面的东西，必不可少的需要了解一下 Https/SSL 的通信原理，在这里将了解的结果做个总结。</p><p>首先，SSL 的通信过程大体可以分为两个阶段：密钥交换（也有的称之为握手）和正式传输。</p><h1 id=密钥交换握手阶段>密钥交换/握手阶段</h1><ol><li><p><strong>首先客户端像服务器发送加密连接请求</strong></p></li><li><p><strong>服务端接收到请求之后，给客户端发送包含 Public Key 的证书</strong></p></li></ol><p>这里之所以不直接发送 Public Key，而是将公钥放在证书中发送给客户端，是因为这样可以防止 Public Key 被篡改。只要证书是可信的，那么 Public Key 就是可信的。另外这个证书通常又叫做 X.509 证书，这个证书由 CA(Certificate Authority)颁发。</p><ol start=3><li><strong>客户端校验证书的合法性。然后客户端生成一个对称加密密钥。并用服务端发送过来的 Public Key 进行加密，最后将加密过后的密钥发送给服务器端</strong></li></ol><ul><li><p><strong>为什么要多生成一个密钥进行加密传输，而不是直接使用 Public key 进行加密？</strong><br>非对称加密，比较安全，但是加解密大量数据的时候性能不行。而对称加密性能好，但是双方密钥都一样，安全性不好。所以 SSL 采用的方法是仅使用非对称加密来加密对称加密的密钥，然后再用这个加密过的密钥加密传输数据。</p></li><li><p><strong>如何进行证书合法性校验？</strong><br>客户端，一般是浏览器，会查找计算机上面的可信证书链，确保发过来的证书是受信任的证书。</p></li></ul><ol start=4><li><strong>服务端用 Private Key 解密发送过来的密钥</strong></li></ol><p>这样双方就在一种可信任的环境下获得了加解密数据的密钥，以后所有的通信数据都通过这个密钥来进行加解密。</p><h1 id=传输阶段>传输阶段</h1><p>经过上面的握手阶段，双方都获得了加密密钥后，直接使用 HTTP 层的协议传输加密过后的数据即可。</p></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=post-comments><div id=disqus_thread></div><script>window.addEventListener("load",()=>{(function(){var d=document,s=d.createElement("script");s.src="https://scottqian.disqus.com/embed.js";s.setAttribute("data-timestamp",+new Date());(d.head||d.body).appendChild(s);})();});</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div><div class=site-footer><div class=site-footer-item><a href=https://github.com/qianlifeng target=_blank>Github</a></div></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>