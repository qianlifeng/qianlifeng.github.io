<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.79.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="https://blog.qlf.io/post/spring-aop/"><link rel=canonical href=https://blog.qlf.io/post/spring-aop/><link rel=preload href=/js/highlight.pack.js as=script><link rel=alternate type=application/atom+xml href=https://blog.qlf.ioindex.xml title=钱李峰的博客><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.qlf.io"},"articleSection":"post","name":"Spring AOP小试","headline":"Spring AOP小试","description":"第一次使用 Spring 的 AOP 拦截，感觉还是很强大的嘛^Q^\n直接来一个最简单的例子，实现一个方法同步的切面。要求是所有注解了@Synchronized的方法都必须同步执行（加锁）。 效果如下：\n@Synchronized public void imporOrder(){ \/\/todo: logic } 如何实现呢？ 首先声明注解：\nimport java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; \/** * 顺序执行方法，防止高并发下的执行顺序问题 *\/ @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Synchronized { } 接着声明切面\nimport org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Component @Aspect @Order(1) public class SynchronizedAspect { public final static Object locker = new Object(); @Around(\u0026#34;@annotation(cn.fcgyl.oms.aspect.Synchronized)()\u0026#34;) public Object doSynchronize(ProceedingJoinPoint pjp) throws Throwable { synchronized (locker) { Object retVal = pjp.","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2015","datePublished":"2015-07-14 20:47:17 \u002b0000 UTC","dateModified":"2015-07-14 20:47:17 \u002b0000 UTC","url":"https:\/\/blog.qlf.io\/post\/spring-aop\/","keywords":[]}</script><title>Spring AOP小试 - 钱李峰的博客</title><meta property="og:title" content="Spring AOP小试 - 钱李峰的博客"><meta property="og:type" content="article"><meta property="og:description" content="第一次使用 Spring 的 AOP 拦截，感觉还是很强大的嘛^Q^
直接来一个最简单的例子，实现一个方法同步的切面。要求是所有注解了@Synchronized的方法都必须同步执行（加锁）。 效果如下：
@Synchronized public void imporOrder(){ //todo: logic } 如何实现呢？ 首先声明注解：
import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** * 顺序执行方法，防止高并发下的执行顺序问题 */ @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Synchronized { } 接着声明切面
import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Component @Aspect @Order(1) public class SynchronizedAspect { public final static Object locker = new Object(); @Around(&#34;@annotation(cn.fcgyl.oms.aspect.Synchronized)()&#34;) public Object doSynchronize(ProceedingJoinPoint pjp) throws Throwable { synchronized (locker) { Object retVal = pjp."><meta name=description content="第一次使用 Spring 的 AOP 拦截，感觉还是很强大的嘛^Q^
直接来一个最简单的例子，实现一个方法同步的切面。要求是所有注解了@Synchronized的方法都必须同步执行（加锁）。 效果如下：
@Synchronized public void imporOrder(){ //todo: logic } 如何实现呢？ 首先声明注解：
import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** * 顺序执行方法，防止高并发下的执行顺序问题 */ @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Synchronized { } 接着声明切面
import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Component @Aspect @Order(1) public class SynchronizedAspect { public final static Object locker = new Object(); @Around(&#34;@annotation(cn.fcgyl.oms.aspect.Synchronized)()&#34;) public Object doSynchronize(ProceedingJoinPoint pjp) throws Throwable { synchronized (locker) { Object retVal = pjp."><meta property="og:locale" content><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml title=钱李峰的博客><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class=post id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>Scott Qian</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>Spring AOP小试</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2015-07-14 20:47:17 UTC">14 Jul 2015</time></div><div class=col-xs-6></div></div></header><div class="post-content markdown-body"><p>第一次使用 Spring 的 AOP 拦截，感觉还是很强大的嘛^Q^</p><p>直接来一个最简单的例子，实现一个方法同步的切面。要求是所有注解了<code>@Synchronized</code>的方法都必须同步执行（加锁）。 效果如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#a6e22e>@Synchronized</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>imporOrder</span><span style=color:#f92672>(){</span>
    <span style=color:#75715e>//todo: logic
</span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</code></pre></div><p>如何实现呢？ 首先声明注解：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#f92672>import</span> java.lang.annotation.ElementType<span style=color:#f92672>;</span>
<span style=color:#f92672>import</span> java.lang.annotation.Retention<span style=color:#f92672>;</span>
<span style=color:#f92672>import</span> java.lang.annotation.RetentionPolicy<span style=color:#f92672>;</span>
<span style=color:#f92672>import</span> java.lang.annotation.Target<span style=color:#f92672>;</span>

<span style=color:#75715e>/**
</span><span style=color:#75715e> * 顺序执行方法，防止高并发下的执行顺序问题
</span><span style=color:#75715e> */</span>
<span style=color:#a6e22e>@Target</span><span style=color:#f92672>(</span>ElementType<span style=color:#f92672>.</span><span style=color:#a6e22e>METHOD</span><span style=color:#f92672>)</span>
<span style=color:#a6e22e>@Retention</span><span style=color:#f92672>(</span>RetentionPolicy<span style=color:#f92672>.</span><span style=color:#a6e22e>RUNTIME</span><span style=color:#f92672>)</span>
<span style=color:#66d9ef>public</span> <span style=color:#a6e22e>@interface</span> Synchronized <span style=color:#f92672>{</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>接着声明切面</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#f92672>import</span> org.aspectj.lang.ProceedingJoinPoint<span style=color:#f92672>;</span>
<span style=color:#f92672>import</span> org.aspectj.lang.annotation.Around<span style=color:#f92672>;</span>
<span style=color:#f92672>import</span> org.aspectj.lang.annotation.Aspect<span style=color:#f92672>;</span>
<span style=color:#f92672>import</span> org.springframework.core.annotation.Order<span style=color:#f92672>;</span>
<span style=color:#f92672>import</span> org.springframework.stereotype.Component<span style=color:#f92672>;</span>

<span style=color:#a6e22e>@Component</span>
<span style=color:#a6e22e>@Aspect</span>
<span style=color:#a6e22e>@Order</span><span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SynchronizedAspect</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>static</span> Object locker <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>();</span>

    <span style=color:#a6e22e>@Around</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;@annotation(cn.fcgyl.oms.aspect.Synchronized)()&#34;</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>doSynchronize</span><span style=color:#f92672>(</span>ProceedingJoinPoint pjp<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Throwable <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span>locker<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            Object retVal <span style=color:#f92672>=</span> pjp<span style=color:#f92672>.</span><span style=color:#a6e22e>proceed</span><span style=color:#f92672>();</span>
            <span style=color:#66d9ef>return</span> retVal<span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><ol><li>定义的切面必须使用<code>@Aspect</code>注解</li><li>注册这个切面 bean 到 Spring，我这里是使用<code>@Component</code>自动装配的</li><li>定义拦截方法（本例中的<code>doSynchronize</code>），同时标注拦截类型。Spring AOP 只支持拦截方法，所以这里的几种拦截类型大概是<code>@Before</code>,<code>@After</code>,<code>@Around</code></li><li>这里的<code>@Order</code>指定了该注解的优先级，越小的数字代表了越高的优先级</li></ol><p>最后启用切面，在 spring 配置文件中配置如下信息：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Xml data-lang=Xml><span style=color:#75715e>&lt;!-- 开启AOP切面 --&gt;</span>
<span style=color:#f92672>&lt;aop:aspectj-autoproxy/&gt;</span>
</code></pre></div><p>大功告成。</p></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=post-comments><div id=disqus_thread></div><script>window.addEventListener("load",()=>{(function(){var d=document,s=d.createElement("script");s.src="https://scottqian.disqus.com/embed.js";s.setAttribute("data-timestamp",+new Date());(d.head||d.body).appendChild(s);})();});</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div><div class=site-footer><div class=site-footer-item><a href=https://github.com/qianlifeng target=_blank>Github</a></div></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>