<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.79.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="https://blog.qlf.io/post/a-httpwebrequest-demo/"><link rel=canonical href=https://blog.qlf.io/post/a-httpwebrequest-demo/><link rel=preload href=/js/highlight.pack.js as=script><link rel=alternate type=application/atom+xml href=https://blog.qlf.ioindex.xml title="Scott Qian"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.qlf.io"},"articleSection":"post","name":"一个httpwebrequest异步下载的例子","headline":"一个httpwebrequest异步下载的例子","description":"最近经常要用到模拟网页的登录，网页的抓取。一开始都是用同步的方法获取，同步在请求量比较小的情况下还可以接受。但是比如我一下子请求上百个，上千个页面就显得力不从心了。昨天终于狠下心来研究了一下异步的获取方式。虽说没有同步的方法简单，不过效率上真的提高了很多。现在记下来，以便以后查阅吧。\nnamespace 异步调用方法 { class Program { static void Main(string[] args) { for (int i = 0; i \u0026lt; 1111; i\u002b\u002b) { HttpWebRequest request = (HttpWebRequest)WebRequest.Create(\u0026quot;http:\/\/www.cnblogs.com\/qianlifeng\/\u0026quot;); request.BeginGetResponse(new AsyncCallback(OnResponse), request); Console.WriteLine(\u0026quot;请求\u0026quot; \u002b i \u002b \u0026quot;完成\u0026quot;); } Console.Read(); } static void OnResponse(IAsyncResult ar) { HttpWebRequest request = (HttpWebRequest)ar.AsyncState; HttpWebResponse response = (HttpWebResponse)request.EndGetResponse(ar); Stream stream = response.GetResponseStream(); StreamReader sr = new StreamReader(stream, Encoding.UTF8); Console.WriteLine( sr.ReadToEnd()); } } } ","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2010","datePublished":"2010-04-23 09:47:17 \u002b0000 UTC","dateModified":"2010-04-23 09:47:17 \u002b0000 UTC","url":"https:\/\/blog.qlf.io\/post\/a-httpwebrequest-demo\/","keywords":[]}</script><title>一个httpwebrequest异步下载的例子 - Scott Qian</title><meta property="og:title" content="一个httpwebrequest异步下载的例子 - Scott Qian"><meta property="og:type" content="article"><meta property="og:description" content="最近经常要用到模拟网页的登录，网页的抓取。一开始都是用同步的方法获取，同步在请求量比较小的情况下还可以接受。但是比如我一下子请求上百个，上千个页面就显得力不从心了。昨天终于狠下心来研究了一下异步的获取方式。虽说没有同步的方法简单，不过效率上真的提高了很多。现在记下来，以便以后查阅吧。
namespace 异步调用方法 { class Program { static void Main(string[] args) { for (int i = 0; i < 1111; i++) { HttpWebRequest request = (HttpWebRequest)WebRequest.Create(&#34;http://www.cnblogs.com/qianlifeng/&#34;); request.BeginGetResponse(new AsyncCallback(OnResponse), request); Console.WriteLine(&#34;请求&#34; + i + &#34;完成&#34;); } Console.Read(); } static void OnResponse(IAsyncResult ar) { HttpWebRequest request = (HttpWebRequest)ar.AsyncState; HttpWebResponse response = (HttpWebResponse)request.EndGetResponse(ar); Stream stream = response.GetResponseStream(); StreamReader sr = new StreamReader(stream, Encoding.UTF8); Console.WriteLine( sr.ReadToEnd()); } } }"><meta name=description content="最近经常要用到模拟网页的登录，网页的抓取。一开始都是用同步的方法获取，同步在请求量比较小的情况下还可以接受。但是比如我一下子请求上百个，上千个页面就显得力不从心了。昨天终于狠下心来研究了一下异步的获取方式。虽说没有同步的方法简单，不过效率上真的提高了很多。现在记下来，以便以后查阅吧。
namespace 异步调用方法 { class Program { static void Main(string[] args) { for (int i = 0; i < 1111; i++) { HttpWebRequest request = (HttpWebRequest)WebRequest.Create(&#34;http://www.cnblogs.com/qianlifeng/&#34;); request.BeginGetResponse(new AsyncCallback(OnResponse), request); Console.WriteLine(&#34;请求&#34; + i + &#34;完成&#34;); } Console.Read(); } static void OnResponse(IAsyncResult ar) { HttpWebRequest request = (HttpWebRequest)ar.AsyncState; HttpWebResponse response = (HttpWebResponse)request.EndGetResponse(ar); Stream stream = response.GetResponseStream(); StreamReader sr = new StreamReader(stream, Encoding.UTF8); Console.WriteLine( sr.ReadToEnd()); } } }"><meta property="og:locale" content><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml title="Scott Qian"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class=post id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>Scott Qian</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>一个httpwebrequest异步下载的例子</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2010-04-23 09:47:17 UTC">23 Apr 2010</time></div><div class=col-xs-6></div></div></header><div class="post-content markdown-body"><p>最近经常要用到模拟网页的登录，网页的抓取。一开始都是用同步的方法获取，同步在请求量比较小的情况下还可以接受。但是比如我一下子请求上百个，上千个页面就显得力不从心了。昨天终于狠下心来研究了一下异步的获取方式。虽说没有同步的方法简单，不过效率上真的提高了很多。现在记下来，以便以后查阅吧。</p><pre><code>namespace 异步调用方法
{
    class Program
    {

        static void Main(string[] args)
        {
            for (int i = 0; i &lt; 1111; i++)
            {
                HttpWebRequest request = (HttpWebRequest)WebRequest.Create(&quot;http://www.cnblogs.com/qianlifeng/&quot;);
                request.BeginGetResponse(new AsyncCallback(OnResponse), request);
                Console.WriteLine(&quot;请求&quot; + i + &quot;完成&quot;);
            }
            Console.Read();
        }

        static void OnResponse(IAsyncResult ar)
        {
            HttpWebRequest request = (HttpWebRequest)ar.AsyncState;
            HttpWebResponse response = (HttpWebResponse)request.EndGetResponse(ar);
            Stream stream = response.GetResponseStream();
            StreamReader sr = new StreamReader(stream, Encoding.UTF8);
            Console.WriteLine( sr.ReadToEnd());
        }
    }
}
</code></pre></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=post-comments><div id=disqus_thread></div><script>window.addEventListener("load",()=>{(function(){var d=document,s=d.createElement("script");s.src="https://scottqian.disqus.com/embed.js";s.setAttribute("data-timestamp",+new Date());(d.head||d.body).appendChild(s);})();});</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div><div class=site-footer><div class=site-footer-item><a href=https://github.com/qianlifeng target=_blank>Github</a></div></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>