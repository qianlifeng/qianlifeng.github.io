<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.79.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="https://blog.qlf.io/post/restful-api-cross-domain-authentication/"><link rel=canonical href=https://blog.qlf.io/post/restful-api-cross-domain-authentication/><link rel=preload href=/js/highlight.pack.js as=script><link rel=alternate type=application/atom+xml href=https://blog.qlf.ioindex.xml title=钱李峰的博客><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.qlf.io"},"articleSection":"post","name":"RESTful api跨域认证","headline":"RESTful api跨域认证","description":"本文主要介绍了 RESTful api 跨域认证的一些知识。包括了什么是跨域，跨域的危害，如何进行合理的跨域认证等。另文中如有不对的地方，欢迎指正.\n前言 在正式介绍 Web Api 跨域认证之前，我想先举一个 web api 跨域认证的例子，就算是需求吧，也有利于后面讲解的时候有例子可说。\n假设现在有两台服务器：Server A 和 Server B。 Server A(域名：https:\/\/www.serverA.com\/api\/) 上面运行着一个提供 Web Api 的程序，此程序中的 api 都需要用户登录以后才能操作。Server B(域名：http:\/\/www.serverB.com) 也有一个程序，专门用来消费这些 Web PI 。\nServerB 上面有一个登录操作，此操作会去请求 ServerA 上面的某个用户认证 api。要求:\n1. 成功请求此api 2. 持久化用户的此次认证，以便用户的后续请求。  什么是跨域 对于上面的要求，如果你直接通过 ajax 请求此认证 api 显然是不行的。为什么？因为这个请求跨域了。那么什么请求才是跨域请求？\n所谓跨域请求是指请求一个与当前url协议不同,或者域名不同,或者端口不同的链接资源。  下面这个表格可以帮助理解什么样的请求是跨域请求。\n这种不能跨域请求的限制又称为：“Same-Origin Policy”（同源策略）。值得注意的是这种安全限制是 Javascript 保证的，也就是说以后如果出来个新的浏览器端语言不带这种限制，那么你就可以随便请求不同域的资源。还有一个例子可以佐证，你直接使用 wget 命令请求 RESTful api 认证的页面同样会有结果返回。因为此处的请求不是由 javascript 发出，已经没有了同源策略的限制了。\n跨域的危害 为什么要采用这种同源策略的限制呢？我们来模拟一下攻击场景。比如说某网站 A 有个 apihttp:\/\/localhost:5000\/api\/getuser，此 API 用来获得当前用户的登陆信息 [ 假设此 API 不需要认证操作 ] 。碰巧的是用户同时在一个新的标签页打开了网站 B。网站 B 下面有这么一段代码：","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2013","datePublished":"2013-11-13 16:24:17 \u002b0000 UTC","dateModified":"2013-11-13 16:24:17 \u002b0000 UTC","url":"https:\/\/blog.qlf.io\/post\/restful-api-cross-domain-authentication\/","keywords":[]}</script><title>RESTful api跨域认证 - 钱李峰的博客</title><meta property="og:title" content="RESTful api跨域认证 - 钱李峰的博客"><meta property="og:type" content="article"><meta property="og:description" content="本文主要介绍了 RESTful api 跨域认证的一些知识。包括了什么是跨域，跨域的危害，如何进行合理的跨域认证等。另文中如有不对的地方，欢迎指正.
前言 在正式介绍 Web Api 跨域认证之前，我想先举一个 web api 跨域认证的例子，就算是需求吧，也有利于后面讲解的时候有例子可说。
假设现在有两台服务器：Server A 和 Server B。 Server A(域名：https://www.serverA.com/api/) 上面运行着一个提供 Web Api 的程序，此程序中的 api 都需要用户登录以后才能操作。Server B(域名：http://www.serverB.com) 也有一个程序，专门用来消费这些 Web PI 。
ServerB 上面有一个登录操作，此操作会去请求 ServerA 上面的某个用户认证 api。要求:
1. 成功请求此api 2. 持久化用户的此次认证，以便用户的后续请求。  什么是跨域 对于上面的要求，如果你直接通过 ajax 请求此认证 api 显然是不行的。为什么？因为这个请求跨域了。那么什么请求才是跨域请求？
所谓跨域请求是指请求一个与当前url协议不同,或者域名不同,或者端口不同的链接资源。  下面这个表格可以帮助理解什么样的请求是跨域请求。
这种不能跨域请求的限制又称为：“Same-Origin Policy”（同源策略）。值得注意的是这种安全限制是 Javascript 保证的，也就是说以后如果出来个新的浏览器端语言不带这种限制，那么你就可以随便请求不同域的资源。还有一个例子可以佐证，你直接使用 wget 命令请求 RESTful api 认证的页面同样会有结果返回。因为此处的请求不是由 javascript 发出，已经没有了同源策略的限制了。
跨域的危害 为什么要采用这种同源策略的限制呢？我们来模拟一下攻击场景。比如说某网站 A 有个 apihttp://localhost:5000/api/getuser，此 API 用来获得当前用户的登陆信息 [ 假设此 API 不需要认证操作 ] 。碰巧的是用户同时在一个新的标签页打开了网站 B。网站 B 下面有这么一段代码："><meta name=description content="本文主要介绍了 RESTful api 跨域认证的一些知识。包括了什么是跨域，跨域的危害，如何进行合理的跨域认证等。另文中如有不对的地方，欢迎指正.
前言 在正式介绍 Web Api 跨域认证之前，我想先举一个 web api 跨域认证的例子，就算是需求吧，也有利于后面讲解的时候有例子可说。
假设现在有两台服务器：Server A 和 Server B。 Server A(域名：https://www.serverA.com/api/) 上面运行着一个提供 Web Api 的程序，此程序中的 api 都需要用户登录以后才能操作。Server B(域名：http://www.serverB.com) 也有一个程序，专门用来消费这些 Web PI 。
ServerB 上面有一个登录操作，此操作会去请求 ServerA 上面的某个用户认证 api。要求:
1. 成功请求此api 2. 持久化用户的此次认证，以便用户的后续请求。  什么是跨域 对于上面的要求，如果你直接通过 ajax 请求此认证 api 显然是不行的。为什么？因为这个请求跨域了。那么什么请求才是跨域请求？
所谓跨域请求是指请求一个与当前url协议不同,或者域名不同,或者端口不同的链接资源。  下面这个表格可以帮助理解什么样的请求是跨域请求。
这种不能跨域请求的限制又称为：“Same-Origin Policy”（同源策略）。值得注意的是这种安全限制是 Javascript 保证的，也就是说以后如果出来个新的浏览器端语言不带这种限制，那么你就可以随便请求不同域的资源。还有一个例子可以佐证，你直接使用 wget 命令请求 RESTful api 认证的页面同样会有结果返回。因为此处的请求不是由 javascript 发出，已经没有了同源策略的限制了。
跨域的危害 为什么要采用这种同源策略的限制呢？我们来模拟一下攻击场景。比如说某网站 A 有个 apihttp://localhost:5000/api/getuser，此 API 用来获得当前用户的登陆信息 [ 假设此 API 不需要认证操作 ] 。碰巧的是用户同时在一个新的标签页打开了网站 B。网站 B 下面有这么一段代码："><meta property="og:locale" content><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml title=钱李峰的博客><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class=post id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>Scott Qian</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>RESTful api跨域认证</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2013-11-13 16:24:17 UTC">13 Nov 2013</time></div><div class=col-xs-6></div></div></header><div class="post-content markdown-body"><p>本文主要介绍了 RESTful api 跨域认证的一些知识。包括了什么是跨域，跨域的危害，如何进行合理的跨域认证等。另文中如有不对的地方，欢迎指正.</p><h1 id=前言>前言</h1><p>在正式介绍 Web Api 跨域认证之前，我想先举一个 web api 跨域认证的例子，就算是需求吧，也有利于后面讲解的时候有例子可说。</p><p>假设现在有两台服务器： Server A 和 Server B。 Server A(域名：https://www.serverA.com/api/) 上面运行着一个提供 Web Api 的程序，此程序中的 api 都需要用户登录以后才能操作。 Server B(域名：http://www.serverB.com) 也有一个程序，专门用来消费这些 Web PI 。</p><p>ServerB 上面有一个登录操作，此操作会去请求 ServerA 上面的某个用户认证 api。要求:</p><pre><code>1. 成功请求此api
2. 持久化用户的此次认证，以便用户的后续请求。
</code></pre><h1 id=什么是跨域>什么是跨域</h1><p>对于上面的要求，如果你直接通过 ajax 请求此认证 api 显然是不行的。为什么？因为这个请求跨域了。那么什么请求才是跨域请求？</p><pre><code>所谓跨域请求是指请求一个与当前url协议不同,或者域名不同,或者端口不同的链接资源。
</code></pre><p>下面这个表格可以帮助理解什么样的请求是跨域请求。</p><p>这种不能跨域请求的限制又称为：“<a href=http://en.wikipedia.org/wiki/Same-origin_policy>Same-Origin Policy</a>”（同源策略）。值得注意的是<strong>这种安全限制是 Javascript 保证的</strong>，也就是说以后如果出来个新的浏览器端语言不带这种限制，那么你就可以随便请求不同域的资源。还有一个例子可以佐证，你直接使用 wget 命令请求 RESTful api 认证的页面同样会有结果返回。因为此处的请求不是由 javascript 发出，已经没有了同源策略的限制了。</p><h1 id=跨域的危害>跨域的危害</h1><p>为什么要采用这种同源策略的限制呢？我们来模拟一下攻击场景。比如说某网站 A 有个 api<code>http://localhost:5000/api/getuser</code>，此 API 用来获得当前用户的登陆信息 [ 假设此 API 不需要认证操作 ] 。碰巧的是用户同时在一个新的标签页打开了网站 B。网站 B 下面有这么一段代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=color:#75715e>&lt;!DOCTYPE html&gt;</span>
&lt;<span style=color:#f92672>html</span>&gt;
    &lt;<span style=color:#f92672>head</span>&gt;
        &lt;<span style=color:#f92672>script</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://codeorigin.jquery.com/jquery-2.0.3.min.js&#34;</span> <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text/javascript&#34;</span>&gt;&lt;/<span style=color:#f92672>script</span>&gt;
    &lt;/<span style=color:#f92672>head</span>&gt;
    &lt;<span style=color:#f92672>body</span>&gt;
        &lt;<span style=color:#f92672>input</span> <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;button&#34;</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;btnGetInfo&#34;</span> <span style=color:#a6e22e>value</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Get&#34;</span>&gt;&lt;/<span style=color:#f92672>a</span>&gt;


        &lt;<span style=color:#f92672>script</span> <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text/javascript&#34;</span>&gt;
            <span style=color:#a6e22e>$</span>(<span style=color:#66d9ef>function</span>(){
                    <span style=color:#a6e22e>$</span>(<span style=color:#e6db74>&#34;#btnGetInfo&#34;</span>).<span style=color:#a6e22e>click</span>(<span style=color:#66d9ef>function</span>(){
                        <span style=color:#a6e22e>$</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;http://localhost:5000/api/getuser/1&#34;</span>)
                            .<span style=color:#a6e22e>success</span>(<span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>d</span>){
                                <span style=color:#a6e22e>alert</span>(<span style=color:#a6e22e>d</span>);
                            });
                    });
            });
        &lt;/<span style=color:#f92672>script</span>&gt;
    &lt;/<span style=color:#f92672>body</span>&gt;
&lt;/<span style=color:#f92672>html</span>&gt;
</code></pre></div><p>如果没有同源策略的限制，那么用户打开网站 B 的同时，网站 B 就可以悄悄获得用户在网站 A 的信息了。如果这个请求换成某个删除 API，那就是大问题了。</p><h1 id=如何进行跨域请求>如何进行跨域请求</h1><p><a href=http://www.ruanyifeng.com/blog/2011/09/restful.html>RESTful</a> api 大行其道的今天，我们需要跨域请求的需求也越来越多。如何进行安全的跨域请求呢？这里介绍几种方法：</p><ul><li><p>JSONP</p><p>JSONP 依赖于这样一个事实：带有 src 属性的标签具有跨域的能力。</p></li></ul><p>比如大家经常看到的各种 CDN 加速就不存在跨域的问题。JSONP 是通过 JS 动态构造这么一个带有 src 属性的标签，比如说 script，src 的链接请求远程的跨域 URL。然后服务器端返回 JSON 格式的数据，而又那么巧 JS 对 JSON 格式原生就支持，所以返回的 JSON 数据拿过来就能用了。Jquery 已经对 JSONP 提供了封装，使用起来和一般的 ajax 请求没多大区别，具体用法大家去搜索一下就是，一大把。</p><p>JSON 有一个缺点就是不能进行 POST 操作，从上面 JSONP 的原理我们很容易得出这个结论。如果你想进行 POST，可以使用下面一种方法。</p><ul><li><a href=http://www.w3.org/TR/cors/>CORS</a>(Cross-Origin Resource Sharing)</li></ul><p>CORS 和 JSONP 不一样，JSONP 有点用了 little trick 的意思，而 CORS 则显得更加正式一些。一旦服务器允许了 CORS，那么客户端代码并不需要特殊的处理。同样还支持 GET,POST 等等方法。</p><p>CORS 的流程是这样的：</p><ol><li><p>通过 ajax 请求跨域资源</p></li><li><p>浏览器检测到跨域请求，此时浏览器会发送一个 OPTION 类型的请求到服务器。该请求是个试探性的请求，意在告诉服务器端有一个跨域请求正在请求，此时服务器端会得到这个请求的信息（请求方法，源请求地址等）。</p></li><li><p>服务器判断是否允许该请求。如果允许，则服务器端在响应头中添加:<code>Access-Control-Allow-Origin</code>标志。</p></li><li><p>客户端接受到服务器端返回，如果成功则正式发起这个跨域请求，此时请求会成功。否则，如果服务端返回不允许，那么客户端的代码也不会被执行。</p></li></ol><p>整个过程就是浏览器与服务器端的一个协商过程，这个过程是透明的，不需要我们写额外的代码。唯一需要我们做的就是在服务器端设置返回<code>Access-Control-Allow-Origin</code>标志。
关于如何在不同的服务器上设置这个标志，有个专门的网站已经写了专门的教程了。<a href=http://enable-cors.org>http://enable-cors.org</a></p><ul><li>Flash</li></ul><p>你也可以把跨域请求放在 Flash 里面，这样就不用受同源策略的限制了。此方法我没用过，只是提一下。</p><h1 id=为什么传统认证方式不行>为什么传统认证方式不行</h1><p>解决了跨域问题，RESTful api 跨域认证就完成了一半了。认证的方式有很多很多，我这里说的传统认证方式是指通过 Cookie 来协助认证的方式，比如 ASP.net 里面的 Form 认证。这类认证大多是通过在 Cookie 写入登陆信息，然后浏览器发送请求后服务端再去验证 Cookie 是否存在，从而达到认证用户的目的。但是我们现在涉及到一个跨域的问题，而<code>Cookie是不能跨站共享的</code>。即使 RESTful 那边设置了 cookie，也不会到当前请求的域下面。到了第二次请求的时候，还是得不到认证信息。</p><h1 id=如何进行跨域认证>如何进行跨域认证</h1><ul><li><a href=http://zh.wikipedia.org/wiki/HTTP%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81>HTTP 基本认证</a></li></ul><blockquote><p>在 HTTP 中，基本认证是一种用来允许 Web 浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式。
在发送之前是以用户名追加一个冒号然后串接上口令，并将得出的结果字符串再用 Base64 算法编码。例如，提供的用户名是 Aladdin、口令是 open sesame，则拼接后的结果就是 Aladdin:open sesame，然后再将其用 Base64 编码，得到 QWxhZGRpbjpvcGVuIHNlc2FtZQ==。最终将 Base64 编码的字符串发送出去，由接收者解码得到一个由冒号分隔的用户名和口令的字符串。</p></blockquote><p>HTTP 的好处就是基本所有的浏览器都支持。缺点就是也太基本了，它假设的前提是客户端和服务端的通信是建立在可信的通信上面的。不然用户的登录信息很容易被获取。如果加上 SSL，那么或许是一种简单可靠的方式。</p><ul><li>OAUTH</li></ul><blockquote><p>OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。
OAuth 允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站（例如，视频编辑网站)在特定的时段（例如，接下来的 2 小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth 让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。</p></blockquote><p>现在使用 OAUTH 认证的网站很多，很多都是使用了新浪微博，QQ 的 AUTH 服务认证。使用 OAUTH 之所以安全，是因为他把登录的风险转移到了认证服务上。当前网站拿到的是一串 token，服务端只认 token 进行授权就行了。<br>如果你开发的应用只是在小范围内使用，比如公司内部，那么其实此应用并不适合 OAUTH。如果你不是用现有的认证服务商，就要自己搭建一个认证服务。略显重量级了。</p><ul><li>自定义认证</li></ul><p>还有一种方法是自己定义认证。既然 Cookie 行不通，那么还有什么东西客户端能够拿得到的。响应头信息！前面提到的<code>Access-Control-Allow-Origin</code>就是一种响应头。如果我们将用户认证成功后的标志放到响应头然后传到客户端，客户端在第二次请求的时候将这个标志再放到响应头中传到服务器，服务器验证通过后再返回带有这种响应头的数据便可。总体和 HTTP 基本认证有些类似。也有不一样。主要是加密过程不再使用简单的 BASE64。</p><p>我目前使用的便是这种方式，代码是 asp.net mvc。上点干活。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TokenInspector</span> : DelegatingHandler
{
    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> TOKEN_NAME = <span style=color:#e6db74>&#34;X-JWT-Token&#34;</span>;
        <span style=color:#66d9ef>if</span> (request.RequestUri.AbsolutePath == <span style=color:#e6db74>&#34;/user/validate&#34;</span>) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>base</span>.SendAsync(request, cancellationToken);
        <span style=color:#66d9ef>if</span> (request.Method == HttpMethod.Options) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>base</span>.SendAsync(request, cancellationToken);

        <span style=color:#66d9ef>if</span> (request.Headers.Contains(TOKEN_NAME))
        {
            <span style=color:#66d9ef>string</span> encryptedToken = request.Headers.GetValues(TOKEN_NAME).First();
            <span style=color:#66d9ef>try</span>
            {
                AuthToken token = AuthToken.Decrypt(encryptedToken);
                <span style=color:#75715e>//bool isValidUserId = IdentityStore.IsValidUserId(token.UserId);
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>bool</span> requestIPMatchesTokenIP = token.IP.Equals(request.GetClientIP());

                <span style=color:#66d9ef>if</span> (!requestIPMatchesTokenIP)
                {
                    HttpResponseMessage reply = request.CreateErrorResponse(HttpStatusCode.Unauthorized, <span style=color:#e6db74>&#34;Invalid identity or client machine.&#34;</span>);
                    <span style=color:#66d9ef>return</span> Task.FromResult(reply);
                }
            }
            <span style=color:#66d9ef>catch</span> (Exception ex)
            {
                HttpResponseMessage reply = request.CreateErrorResponse(HttpStatusCode.Unauthorized, <span style=color:#e6db74>&#34;Invalid token.&#34;</span>);
                <span style=color:#66d9ef>return</span> Task.FromResult(reply);
            }
        }
        <span style=color:#66d9ef>else</span>
        {
            HttpResponseMessage reply = request.CreateErrorResponse(HttpStatusCode.Unauthorized, <span style=color:#e6db74>&#34;Request is missing authorization token.&#34;</span>);
            <span style=color:#66d9ef>return</span> Task.FromResult(reply);
        }

        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>base</span>.SendAsync(request, cancellationToken);
    }

}

</code></pre></div><p>DelegatingHandler 这个类用来拦截 HTTP 消息的，有点类似于 HTTPModule 的作用，不过 HTTPModule 是 IIS 的东西。而这个 DelegatingHandler 是属于 asp.net mvc 里面的。可以看到我们在每个请求的时候，都会去检查一下请求头中是否存在特定的头。如果没有或者认证失败，就返回认证失败。<br>在用户认证的时候，我们只需要在响应头中添加特定的头信息进去，然后让客户端每次请求的时候附上此头信息即可。（通过 jquery 的全部 ajax 设定可以很容易做到）</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#>AuthToken token = <span style=color:#66d9ef>new</span> AuthToken(user.UserName, HttpContext.Current.Request.UserHostAddress,DateTime.Now);
HttpContext.Current.Response.AddHeader(<span style=color:#e6db74>&#34;X-JWT-Token&#34;</span>, token.Encrypt());
<span style=color:#75715e>// must set this, otherwise jquery can&#39;t access X-JWT-Token header
</span><span style=color:#75715e></span>HttpContext.Current.Response.AddHeader(<span style=color:#e6db74>&#34;Access-Control-Expose-Headers&#34;</span>, <span style=color:#e6db74>&#34;X-JWT-Token&#34;</span>);
</code></pre></div><p>使用自定义的方式，我们还要考虑这个头的时效性问题，如何防止中间人攻击等等问题。不过已经不属于这次的内容了，基本的跨域认证已经可以完成了。</p></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=post-comments><div id=disqus_thread></div><script>window.addEventListener("load",()=>{(function(){var d=document,s=d.createElement("script");s.src="https://scottqian.disqus.com/embed.js";s.setAttribute("data-timestamp",+new Date());(d.head||d.body).appendChild(s);})();});</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div><div class=site-footer><div class=site-footer-item><a href=https://github.com/qianlifeng target=_blank>Github</a></div></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>