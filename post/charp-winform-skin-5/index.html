<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.79.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="https://blog.qlf.io/post/charp-winform-skin-5/"><link rel=canonical href=https://blog.qlf.io/post/charp-winform-skin-5/><link rel=preload href=/js/highlight.pack.js as=script><link rel=alternate type=application/atom+xml href=https://blog.qlf.ioindex.xml title="Scott Qian"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.qlf.io"},"articleSection":"post","name":"跟我学做c#皮肤美化（五）","headline":"跟我学做c#皮肤美化（五）","description":"本篇主要解决上篇遗留的一些问题\n先来回顾一下我们上次遗留的问题\n 消除图中不透明的地方 实现标题栏的拖动 实现窗体的最大化，最小化，关闭功能。  下面就来一个一个解决。\n解决不透明的问题\n首先为什么会有灰色的出现呢。不难想到这些灰色就是 Picturebox 的背景色。边角上的图片对粉红色透明了，但却露出了背景的颜色。知道了原因就好了解决了，就是我们需要将这一块的背景色给透明掉。有人说可以讲 picturebox 的背景色设置为透明的啊。不错，是可以，但整个窗体的背景色呢？picturebox 下面不还是有整个被覆盖的窗体的嘛！窗体是不能像用户控件那样背景色设置为透明的，不过却有一个属性 TransparencyKey 可以间接的为我们解决这个问题。这个属性的作用是这样的，当这个属性设置为某一种颜色后，那该窗体上的所有的这种颜色将都变为透明色。\n所以我们只需将 TransparencyKey 的颜色和窗体的背景色设置成一样，那么背景色不就自动透明了嘛！在这里我们将所有控件的背景色和 TransparencyKey 都设置成系统里面的 Info 颜色（这个颜色你可以自己指定，不过不建议是原来的 Control 色，因为这样后你再添加一个普通的控件，那么这个控件的一部分也会被透明掉）\n实现标题栏的拖动\n因为我们的窗体是没有状态栏的，所以当我们想移动窗口的时候发现怎么也”移不动”(不是有个笑话的嘛“中国移不动“,呵呵)。要解决这个问题还是需要借助 API 来完成。那如何知道别人需要移动窗体呢？这里我们就通过 MouseDown 这个事件来判断。即如果用户在特定的区域内按下了鼠标左键，那么我们就认为用户需要移动客户端了。这个时候我们调用相应的 API 向系统通知（SendMessage）让系统做出响应。为了效果好一点，我们将状态栏那一行的所有的 MouseDown 事件都用这个方法。于是现在我们运行一下看看能否移动窗体。\n很不错嘛！又是一个问题解决了，现在只要将右上方的三个按钮的功能完成那这个窗体就算基本完成了啦。好了，我们继续。\n要处理按钮的事件，毫无疑问我们在设计模式中双击对应的按钮，然后处理。这里还要提一下的就是我们需要在这些事件的每个方法钱加一个 virtual 让这些个方法可以被重写。道理很简单，假如我按关闭按钮的时候不想其直接关闭而是先弹出对话框提醒一下用户怎么办呢？总不能让用这个控件的人再去修改这个皮肤控件吧，最好的办法就是可以让他们重写按钮的 click 事件，他们想干嘛干嘛，不想有其他的功能只要不重写就是了。\n好了开始说最小化功能吧\n很简单，一句话搞定：this.WindowState = FormWindowState.Minimized;然后是关闭按钮，还是一句话的事情：this.close();呵呵貌似这两个功能真简单那！原本最大化也不复杂的，可是遇到了前面说到的那个问题，我们就知道想点儿其他的办法啦。看代码：\n当用户点击最大化按钮的时候我们先将最大化按钮上移隐藏，然后将还原按钮降下（还记得我们一开始给他设置的位置是-30 吗？），然后我们最大化之前就先记录窗体的大小和位置（就是最开始赋值的那四句话）信息便于后面的还原。接下来的四句就是咱们手动来制造一种窗体最大化的状态啦，首先位置肯定在左上角。然后大小应该就是用户电脑屏幕客户区的大小，这个大小我是用 Screen.PrimaryScreen.WorkingArea 这个函数得到的。状态设置完了我们只要改一下窗体的状态标识 st 为 stat.Max。然后当用户想还原的时候我们只要在 btres 的 click 的点击事件中做一下刚才那个动作的反就行了。怎么样,是不是也不难啊！Ok，最后看一下运行效果：\n发现问题：\n终于是做好了。不过假如你也实际跟我动手做出了一个，你或许会发现以下一些问题：\n 点击最大化的时候反应好像有点慢，意思就是大概要过个这个半秒钟才会最大化。 还有一个问题就是从最小化状态下恢复到最大化状态，窗体左上角会有闪烁现象(闪的实在太快了，没办法截图啊，大家可以应用下我下面上传的 DLL 运行下就知道了)。我们本来就是想美化窗口，但是如果这些个问题一来实在是给人感觉不好，甚至还不如不美化。在下一篇中我将会带领大家解决这个问题。 我们的窗体位置虽然能移动了，不过大小还不能拖动。  在下一篇中我会带领大家解决这些问题，敬请期待！","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2010","datePublished":"2010-04-23 09:56:17 \u002b0000 UTC","dateModified":"2010-04-23 09:56:17 \u002b0000 UTC","url":"https:\/\/blog.qlf.io\/post\/charp-winform-skin-5\/","keywords":[]}</script><title>跟我学做c#皮肤美化（五） - Scott Qian</title><meta property="og:title" content="跟我学做c#皮肤美化（五） - Scott Qian"><meta property="og:type" content="article"><meta property="og:description" content="本篇主要解决上篇遗留的一些问题
先来回顾一下我们上次遗留的问题
 消除图中不透明的地方 实现标题栏的拖动 实现窗体的最大化，最小化，关闭功能。  下面就来一个一个解决。
解决不透明的问题
首先为什么会有灰色的出现呢。不难想到这些灰色就是 Picturebox 的背景色。边角上的图片对粉红色透明了，但却露出了背景的颜色。知道了原因就好了解决了，就是我们需要将这一块的背景色给透明掉。有人说可以讲 picturebox 的背景色设置为透明的啊。不错，是可以，但整个窗体的背景色呢？picturebox 下面不还是有整个被覆盖的窗体的嘛！窗体是不能像用户控件那样背景色设置为透明的，不过却有一个属性 TransparencyKey 可以间接的为我们解决这个问题。这个属性的作用是这样的，当这个属性设置为某一种颜色后，那该窗体上的所有的这种颜色将都变为透明色。
所以我们只需将 TransparencyKey 的颜色和窗体的背景色设置成一样，那么背景色不就自动透明了嘛！在这里我们将所有控件的背景色和 TransparencyKey 都设置成系统里面的 Info 颜色（这个颜色你可以自己指定，不过不建议是原来的 Control 色，因为这样后你再添加一个普通的控件，那么这个控件的一部分也会被透明掉）
实现标题栏的拖动
因为我们的窗体是没有状态栏的，所以当我们想移动窗口的时候发现怎么也”移不动”(不是有个笑话的嘛“中国移不动“,呵呵)。要解决这个问题还是需要借助 API 来完成。那如何知道别人需要移动窗体呢？这里我们就通过 MouseDown 这个事件来判断。即如果用户在特定的区域内按下了鼠标左键，那么我们就认为用户需要移动客户端了。这个时候我们调用相应的 API 向系统通知（SendMessage）让系统做出响应。为了效果好一点，我们将状态栏那一行的所有的 MouseDown 事件都用这个方法。于是现在我们运行一下看看能否移动窗体。
很不错嘛！又是一个问题解决了，现在只要将右上方的三个按钮的功能完成那这个窗体就算基本完成了啦。好了，我们继续。
要处理按钮的事件，毫无疑问我们在设计模式中双击对应的按钮，然后处理。这里还要提一下的就是我们需要在这些事件的每个方法钱加一个 virtual 让这些个方法可以被重写。道理很简单，假如我按关闭按钮的时候不想其直接关闭而是先弹出对话框提醒一下用户怎么办呢？总不能让用这个控件的人再去修改这个皮肤控件吧，最好的办法就是可以让他们重写按钮的 click 事件，他们想干嘛干嘛，不想有其他的功能只要不重写就是了。
好了开始说最小化功能吧
很简单，一句话搞定：this.WindowState = FormWindowState.Minimized;然后是关闭按钮，还是一句话的事情：this.close();呵呵貌似这两个功能真简单那！原本最大化也不复杂的，可是遇到了前面说到的那个问题，我们就知道想点儿其他的办法啦。看代码：
当用户点击最大化按钮的时候我们先将最大化按钮上移隐藏，然后将还原按钮降下（还记得我们一开始给他设置的位置是-30 吗？），然后我们最大化之前就先记录窗体的大小和位置（就是最开始赋值的那四句话）信息便于后面的还原。接下来的四句就是咱们手动来制造一种窗体最大化的状态啦，首先位置肯定在左上角。然后大小应该就是用户电脑屏幕客户区的大小，这个大小我是用 Screen.PrimaryScreen.WorkingArea 这个函数得到的。状态设置完了我们只要改一下窗体的状态标识 st 为 stat.Max。然后当用户想还原的时候我们只要在 btres 的 click 的点击事件中做一下刚才那个动作的反就行了。怎么样,是不是也不难啊！Ok，最后看一下运行效果：
发现问题：
终于是做好了。不过假如你也实际跟我动手做出了一个，你或许会发现以下一些问题：
 点击最大化的时候反应好像有点慢，意思就是大概要过个这个半秒钟才会最大化。 还有一个问题就是从最小化状态下恢复到最大化状态，窗体左上角会有闪烁现象(闪的实在太快了，没办法截图啊，大家可以应用下我下面上传的 DLL 运行下就知道了)。我们本来就是想美化窗口，但是如果这些个问题一来实在是给人感觉不好，甚至还不如不美化。在下一篇中我将会带领大家解决这个问题。 我们的窗体位置虽然能移动了，不过大小还不能拖动。  在下一篇中我会带领大家解决这些问题，敬请期待！"><meta name=description content="本篇主要解决上篇遗留的一些问题
先来回顾一下我们上次遗留的问题
 消除图中不透明的地方 实现标题栏的拖动 实现窗体的最大化，最小化，关闭功能。  下面就来一个一个解决。
解决不透明的问题
首先为什么会有灰色的出现呢。不难想到这些灰色就是 Picturebox 的背景色。边角上的图片对粉红色透明了，但却露出了背景的颜色。知道了原因就好了解决了，就是我们需要将这一块的背景色给透明掉。有人说可以讲 picturebox 的背景色设置为透明的啊。不错，是可以，但整个窗体的背景色呢？picturebox 下面不还是有整个被覆盖的窗体的嘛！窗体是不能像用户控件那样背景色设置为透明的，不过却有一个属性 TransparencyKey 可以间接的为我们解决这个问题。这个属性的作用是这样的，当这个属性设置为某一种颜色后，那该窗体上的所有的这种颜色将都变为透明色。
所以我们只需将 TransparencyKey 的颜色和窗体的背景色设置成一样，那么背景色不就自动透明了嘛！在这里我们将所有控件的背景色和 TransparencyKey 都设置成系统里面的 Info 颜色（这个颜色你可以自己指定，不过不建议是原来的 Control 色，因为这样后你再添加一个普通的控件，那么这个控件的一部分也会被透明掉）
实现标题栏的拖动
因为我们的窗体是没有状态栏的，所以当我们想移动窗口的时候发现怎么也”移不动”(不是有个笑话的嘛“中国移不动“,呵呵)。要解决这个问题还是需要借助 API 来完成。那如何知道别人需要移动窗体呢？这里我们就通过 MouseDown 这个事件来判断。即如果用户在特定的区域内按下了鼠标左键，那么我们就认为用户需要移动客户端了。这个时候我们调用相应的 API 向系统通知（SendMessage）让系统做出响应。为了效果好一点，我们将状态栏那一行的所有的 MouseDown 事件都用这个方法。于是现在我们运行一下看看能否移动窗体。
很不错嘛！又是一个问题解决了，现在只要将右上方的三个按钮的功能完成那这个窗体就算基本完成了啦。好了，我们继续。
要处理按钮的事件，毫无疑问我们在设计模式中双击对应的按钮，然后处理。这里还要提一下的就是我们需要在这些事件的每个方法钱加一个 virtual 让这些个方法可以被重写。道理很简单，假如我按关闭按钮的时候不想其直接关闭而是先弹出对话框提醒一下用户怎么办呢？总不能让用这个控件的人再去修改这个皮肤控件吧，最好的办法就是可以让他们重写按钮的 click 事件，他们想干嘛干嘛，不想有其他的功能只要不重写就是了。
好了开始说最小化功能吧
很简单，一句话搞定：this.WindowState = FormWindowState.Minimized;然后是关闭按钮，还是一句话的事情：this.close();呵呵貌似这两个功能真简单那！原本最大化也不复杂的，可是遇到了前面说到的那个问题，我们就知道想点儿其他的办法啦。看代码：
当用户点击最大化按钮的时候我们先将最大化按钮上移隐藏，然后将还原按钮降下（还记得我们一开始给他设置的位置是-30 吗？），然后我们最大化之前就先记录窗体的大小和位置（就是最开始赋值的那四句话）信息便于后面的还原。接下来的四句就是咱们手动来制造一种窗体最大化的状态啦，首先位置肯定在左上角。然后大小应该就是用户电脑屏幕客户区的大小，这个大小我是用 Screen.PrimaryScreen.WorkingArea 这个函数得到的。状态设置完了我们只要改一下窗体的状态标识 st 为 stat.Max。然后当用户想还原的时候我们只要在 btres 的 click 的点击事件中做一下刚才那个动作的反就行了。怎么样,是不是也不难啊！Ok，最后看一下运行效果：
发现问题：
终于是做好了。不过假如你也实际跟我动手做出了一个，你或许会发现以下一些问题：
 点击最大化的时候反应好像有点慢，意思就是大概要过个这个半秒钟才会最大化。 还有一个问题就是从最小化状态下恢复到最大化状态，窗体左上角会有闪烁现象(闪的实在太快了，没办法截图啊，大家可以应用下我下面上传的 DLL 运行下就知道了)。我们本来就是想美化窗口，但是如果这些个问题一来实在是给人感觉不好，甚至还不如不美化。在下一篇中我将会带领大家解决这个问题。 我们的窗体位置虽然能移动了，不过大小还不能拖动。  在下一篇中我会带领大家解决这些问题，敬请期待！"><meta property="og:locale" content><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml title="Scott Qian"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class=post id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>Scott Qian</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>跟我学做c#皮肤美化（五）</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2010-04-23 09:56:17 UTC">23 Apr 2010</time></div><div class=col-xs-6></div></div></header><div class="post-content markdown-body"><p>本篇主要解决上篇遗留的一些问题</p><p>先来回顾一下我们上次遗留的问题</p><ol><li>消除图中不透明的地方</li><li>实现标题栏的拖动</li><li>实现窗体的最大化，最小化，关闭功能。</li></ol><p>下面就来一个一个解决。</p><p><strong>解决不透明的问题</strong></p><p>首先为什么会有灰色的出现呢。不难想到这些灰色就是 Picturebox 的背景色。边角上的图片对粉红色透明了，但却露出了背景的颜色。知道了原因就好了解决了，就是我们需要将这一块的背景色给透明掉。有人说可以讲 picturebox 的背景色设置为透明的啊。不错，是可以，但整个窗体的背景色呢？picturebox 下面不还是有整个被覆盖的窗体的嘛！窗体是不能像用户控件那样背景色设置为透明的，不过却有一个属性 TransparencyKey 可以间接的为我们解决这个问题。这个属性的作用是这样的，当这个属性设置为某一种颜色后，那该窗体上的所有的这种颜色将都变为透明色。</p><p>所以我们只需将 TransparencyKey 的颜色和窗体的背景色设置成一样，那么背景色不就自动透明了嘛！在这里我们将所有控件的背景色和 TransparencyKey 都设置成系统里面的 Info 颜色（这个颜色你可以自己指定，不过不建议是原来的 Control 色，因为这样后你再添加一个普通的控件，那么这个控件的一部分也会被透明掉）</p><p><strong>实现标题栏的拖动</strong></p><p>因为我们的窗体是没有状态栏的，所以当我们想移动窗口的时候发现怎么也”移不动”(不是有个笑话的嘛“中国移不动“,呵呵)。要解决这个问题还是需要借助 API 来完成。那如何知道别人需要移动窗体呢？这里我们就通过 MouseDown 这个事件来判断。即如果用户在特定的区域内按下了鼠标左键，那么我们就认为用户需要移动客户端了。这个时候我们调用相应的 API 向系统通知（SendMessage）让系统做出响应。为了效果好一点，我们将状态栏那一行的所有的 MouseDown 事件都用这个方法。于是现在我们运行一下看看能否移动窗体。</p><p><img src=http://ww3.sinaimg.cn/large/5d7c1fa4gw1elx3bkb41uj20p00emjtb.jpg alt></p><p>很不错嘛！又是一个问题解决了，现在只要将右上方的三个按钮的功能完成那这个窗体就算基本完成了啦。好了，我们继续。</p><p>要处理按钮的事件，毫无疑问我们在设计模式中双击对应的按钮，然后处理。这里还要提一下的就是我们需要在这些事件的每个方法钱加一个 virtual 让这些个方法可以被重写。道理很简单，假如我按关闭按钮的时候不想其直接关闭而是先弹出对话框提醒一下用户怎么办呢？总不能让用这个控件的人再去修改这个皮肤控件吧，最好的办法就是可以让他们重写按钮的 click 事件，他们想干嘛干嘛，不想有其他的功能只要不重写就是了。</p><p><strong>好了开始说最小化功能吧</strong></p><p>很简单，一句话搞定：this.WindowState = FormWindowState.Minimized;然后是关闭按钮，还是一句话的事情：this.close();呵呵貌似这两个功能真简单那！原本最大化也不复杂的，可是遇到了前面说到的那个问题，我们就知道想点儿其他的办法啦。看代码：</p><p>当用户点击最大化按钮的时候我们先将最大化按钮上移隐藏，然后将还原按钮降下（还记得我们一开始给他设置的位置是-30 吗？），然后我们最大化之前就先记录窗体的大小和位置（就是最开始赋值的那四句话）信息便于后面的还原。接下来的四句就是咱们手动来制造一种窗体最大化的状态啦，首先位置肯定在左上角。然后大小应该就是用户电脑屏幕客户区的大小，这个大小我是用 Screen.PrimaryScreen.WorkingArea 这个函数得到的。状态设置完了我们只要改一下窗体的状态标识 st 为 stat.Max。然后当用户想还原的时候我们只要在 btres 的 click 的点击事件中做一下刚才那个动作的反就行了。怎么样,是不是也不难啊！Ok，最后看一下运行效果：</p><p><img src=http://ww2.sinaimg.cn/large/5d7c1fa4gw1elx3cf4dgrj208w08smx7.jpg alt></p><p>发现问题：</p><p>终于是做好了。不过假如你也实际跟我动手做出了一个，你或许会发现以下一些问题：</p><ol><li>点击最大化的时候反应好像有点慢，意思就是大概要过个这个半秒钟才会最大化。</li><li>还有一个问题就是从最小化状态下恢复到最大化状态，窗体左上角会有闪烁现象(闪的实在太快了，没办法截图啊，大家可以应用下我下面上传的 DLL 运行下就知道了)。我们本来就是想美化窗口，但是如果这些个问题一来实在是给人感觉不好，甚至还不如不美化。在下一篇中我将会带领大家解决这个问题。</li><li>我们的窗体位置虽然能移动了，不过大小还不能拖动。</li></ol><p>在下一篇中我会带领大家解决这些问题，敬请期待！</p></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=post-comments><div id=disqus_thread></div><script>window.addEventListener("load",()=>{(function(){var d=document,s=d.createElement("script");s.src="https://scottqian.disqus.com/embed.js";s.setAttribute("data-timestamp",+new Date());(d.head||d.body).appendChild(s);})();});</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div><div class=site-footer><div class=site-footer-item><a href=https://github.com/qianlifeng target=_blank>Github</a></div></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>